{"ast":null,"code":"import { InstancedInterleavedBuffer, InterleavedBufferAttribute, Line3, MathUtils, Matrix4, Mesh, Vector3, Vector4 } from \"../../../build/three.module.js\";\nimport { LineSegmentsGeometry } from \"../lines/LineSegmentsGeometry.js\";\nimport { LineMaterial } from \"../lines/LineMaterial.js\";\nvar LineSegments2 = function (geometry, material) {\n  if (geometry === undefined) geometry = new LineSegmentsGeometry();\n  if (material === undefined) material = new LineMaterial({\n    color: Math.random() * 0xffffff\n  });\n  Mesh.call(this, geometry, material);\n  this.type = 'LineSegments2';\n};\nLineSegments2.prototype = Object.assign(Object.create(Mesh.prototype), {\n  constructor: LineSegments2,\n  isLineSegments2: true,\n  computeLineDistances: function () {\n    // for backwards-compatability, but could be a method of LineSegmentsGeometry...\n\n    var start = new Vector3();\n    var end = new Vector3();\n    return function computeLineDistances() {\n      var geometry = this.geometry;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n      var lineDistances = new Float32Array(2 * instanceStart.data.count);\n      for (var i = 0, j = 0, l = instanceStart.data.count; i < l; i++, j += 2) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        lineDistances[j] = j === 0 ? 0 : lineDistances[j - 1];\n        lineDistances[j + 1] = lineDistances[j] + start.distanceTo(end);\n      }\n      var instanceDistanceBuffer = new InstancedInterleavedBuffer(lineDistances, 2, 1); // d0, d1\n\n      geometry.setAttribute('instanceDistanceStart', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 0)); // d0\n      geometry.setAttribute('instanceDistanceEnd', new InterleavedBufferAttribute(instanceDistanceBuffer, 1, 1)); // d1\n\n      return this;\n    };\n  }(),\n  raycast: function () {\n    var start = new Vector4();\n    var end = new Vector4();\n    var ssOrigin = new Vector4();\n    var ssOrigin3 = new Vector3();\n    var mvMatrix = new Matrix4();\n    var line = new Line3();\n    var closestPoint = new Vector3();\n    return function raycast(raycaster, intersects) {\n      if (raycaster.camera === null) {\n        console.error('LineSegments2: \"Raycaster.camera\" needs to be set in order to raycast against LineSegments2.');\n      }\n      var threshold = raycaster.params.Line2 !== undefined ? raycaster.params.Line2.threshold || 0 : 0;\n      var ray = raycaster.ray;\n      var camera = raycaster.camera;\n      var projectionMatrix = camera.projectionMatrix;\n      var geometry = this.geometry;\n      var material = this.material;\n      var resolution = material.resolution;\n      var lineWidth = material.linewidth + threshold;\n      var instanceStart = geometry.attributes.instanceStart;\n      var instanceEnd = geometry.attributes.instanceEnd;\n\n      // pick a point 1 unit out along the ray to avoid the ray origin\n      // sitting at the camera origin which will cause \"w\" to be 0 when\n      // applying the projection matrix.\n      ray.at(1, ssOrigin);\n\n      // ndc space [ - 1.0, 1.0 ]\n      ssOrigin.w = 1;\n      ssOrigin.applyMatrix4(camera.matrixWorldInverse);\n      ssOrigin.applyMatrix4(projectionMatrix);\n      ssOrigin.multiplyScalar(1 / ssOrigin.w);\n\n      // screen space\n      ssOrigin.x *= resolution.x / 2;\n      ssOrigin.y *= resolution.y / 2;\n      ssOrigin.z = 0;\n      ssOrigin3.copy(ssOrigin);\n      var matrixWorld = this.matrixWorld;\n      mvMatrix.multiplyMatrices(camera.matrixWorldInverse, matrixWorld);\n      for (var i = 0, l = instanceStart.count; i < l; i++) {\n        start.fromBufferAttribute(instanceStart, i);\n        end.fromBufferAttribute(instanceEnd, i);\n        start.w = 1;\n        end.w = 1;\n\n        // camera space\n        start.applyMatrix4(mvMatrix);\n        end.applyMatrix4(mvMatrix);\n\n        // clip space\n        start.applyMatrix4(projectionMatrix);\n        end.applyMatrix4(projectionMatrix);\n\n        // ndc space [ - 1.0, 1.0 ]\n        start.multiplyScalar(1 / start.w);\n        end.multiplyScalar(1 / end.w);\n\n        // skip the segment if it's outside the camera near and far planes\n        var isBehindCameraNear = start.z < -1 && end.z < -1;\n        var isPastCameraFar = start.z > 1 && end.z > 1;\n        if (isBehindCameraNear || isPastCameraFar) {\n          continue;\n        }\n\n        // screen space\n        start.x *= resolution.x / 2;\n        start.y *= resolution.y / 2;\n        end.x *= resolution.x / 2;\n        end.y *= resolution.y / 2;\n\n        // create 2d segment\n        line.start.copy(start);\n        line.start.z = 0;\n        line.end.copy(end);\n        line.end.z = 0;\n\n        // get closest point on ray to segment\n        var param = line.closestPointToPointParameter(ssOrigin3, true);\n        line.at(param, closestPoint);\n\n        // check if the intersection point is within clip space\n        var zPos = MathUtils.lerp(start.z, end.z, param);\n        var isInClipSpace = zPos >= -1 && zPos <= 1;\n        var isInside = ssOrigin3.distanceTo(closestPoint) < lineWidth * 0.5;\n        if (isInClipSpace && isInside) {\n          line.start.fromBufferAttribute(instanceStart, i);\n          line.end.fromBufferAttribute(instanceEnd, i);\n          line.start.applyMatrix4(matrixWorld);\n          line.end.applyMatrix4(matrixWorld);\n          var pointOnLine = new Vector3();\n          var point = new Vector3();\n          ray.distanceSqToSegment(line.start, line.end, point, pointOnLine);\n          intersects.push({\n            point: point,\n            pointOnLine: pointOnLine,\n            distance: ray.origin.distanceTo(point),\n            object: this,\n            face: null,\n            faceIndex: i,\n            uv: null,\n            uv2: null\n          });\n        }\n      }\n    };\n  }()\n});\nexport { LineSegments2 };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}