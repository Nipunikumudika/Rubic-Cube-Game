{"ast":null,"code":"import { BufferAttribute, BufferGeometry, Vector3 } from 'three';\nimport * as BufferGeometryUtils from '../utils/BufferGeometryUtils.js';\nconst _A = new Vector3();\nconst _B = new Vector3();\nconst _C = new Vector3();\nclass EdgeSplitModifier {\n  modify(geometry, cutOffAngle, tryKeepNormals = true) {\n    function computeNormals() {\n      normals = new Float32Array(indexes.length * 3);\n      for (let i = 0; i < indexes.length; i += 3) {\n        let index = indexes[i];\n        _A.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 1];\n        _B.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        index = indexes[i + 2];\n        _C.set(positions[3 * index], positions[3 * index + 1], positions[3 * index + 2]);\n        _C.sub(_B);\n        _A.sub(_B);\n        const normal = _C.cross(_A).normalize();\n        for (let j = 0; j < 3; j++) {\n          normals[3 * (i + j)] = normal.x;\n          normals[3 * (i + j) + 1] = normal.y;\n          normals[3 * (i + j) + 2] = normal.z;\n        }\n      }\n    }\n    function mapPositionsToIndexes() {\n      pointToIndexMap = Array(positions.length / 3);\n      for (let i = 0; i < indexes.length; i++) {\n        const index = indexes[i];\n        if (pointToIndexMap[index] == null) {\n          pointToIndexMap[index] = [];\n        }\n        pointToIndexMap[index].push(i);\n      }\n    }\n    function edgeSplitToGroups(indexes, cutOff, firstIndex) {\n      _A.set(normals[3 * firstIndex], normals[3 * firstIndex + 1], normals[3 * firstIndex + 2]).normalize();\n      const result = {\n        splitGroup: [],\n        currentGroup: [firstIndex]\n      };\n      for (const j of indexes) {\n        if (j !== firstIndex) {\n          _B.set(normals[3 * j], normals[3 * j + 1], normals[3 * j + 2]).normalize();\n          if (_B.dot(_A) < cutOff) {\n            result.splitGroup.push(j);\n          } else {\n            result.currentGroup.push(j);\n          }\n        }\n      }\n      return result;\n    }\n    function edgeSplit(indexes, cutOff, original = null) {\n      if (indexes.length === 0) return;\n      const groupResults = [];\n      for (const index of indexes) {\n        groupResults.push(edgeSplitToGroups(indexes, cutOff, index));\n      }\n      let result = groupResults[0];\n      for (const groupResult of groupResults) {\n        if (groupResult.currentGroup.length > result.currentGroup.length) {\n          result = groupResult;\n        }\n      }\n      if (original != null) {\n        splitIndexes.push({\n          original: original,\n          indexes: result.currentGroup\n        });\n      }\n      if (result.splitGroup.length) {\n        edgeSplit(result.splitGroup, cutOff, original || result.currentGroup[0]);\n      }\n    }\n    let hadNormals = false;\n    let oldNormals = null;\n    if (geometry.attributes.normal) {\n      hadNormals = true;\n      geometry = geometry.clone();\n      if (tryKeepNormals === true && geometry.index !== null) {\n        oldNormals = geometry.attributes.normal.array;\n      }\n      geometry.deleteAttribute('normal');\n    }\n    if (geometry.index == null) {\n      geometry = BufferGeometryUtils.mergeVertices(geometry);\n    }\n    const indexes = geometry.index.array;\n    const positions = geometry.getAttribute('position').array;\n    let normals;\n    let pointToIndexMap;\n    computeNormals();\n    mapPositionsToIndexes();\n    const splitIndexes = [];\n    for (const vertexIndexes of pointToIndexMap) {\n      edgeSplit(vertexIndexes, Math.cos(cutOffAngle) - 0.001);\n    }\n    const newAttributes = {};\n    for (const name of Object.keys(geometry.attributes)) {\n      const oldAttribute = geometry.attributes[name];\n      const newArray = new oldAttribute.array.constructor((indexes.length + splitIndexes.length) * oldAttribute.itemSize);\n      newArray.set(oldAttribute.array);\n      newAttributes[name] = new BufferAttribute(newArray, oldAttribute.itemSize, oldAttribute.normalized);\n    }\n    const newIndexes = new Uint32Array(indexes.length);\n    newIndexes.set(indexes);\n    for (let i = 0; i < splitIndexes.length; i++) {\n      const split = splitIndexes[i];\n      const index = indexes[split.original];\n      for (const attribute of Object.values(newAttributes)) {\n        for (let j = 0; j < attribute.itemSize; j++) {\n          attribute.array[(indexes.length + i) * attribute.itemSize + j] = attribute.array[index * attribute.itemSize + j];\n        }\n      }\n      for (const j of split.indexes) {\n        newIndexes[j] = indexes.length + i;\n      }\n    }\n    geometry = new BufferGeometry();\n    geometry.setIndex(new BufferAttribute(newIndexes, 1));\n    for (const name of Object.keys(newAttributes)) {\n      geometry.setAttribute(name, newAttributes[name]);\n    }\n    if (hadNormals) {\n      geometry.computeVertexNormals();\n      if (oldNormals !== null) {\n        const changedNormals = new Array(oldNormals.length / 3).fill(false);\n        for (const splitData of splitIndexes) changedNormals[splitData.original] = true;\n        for (let i = 0; i < changedNormals.length; i++) {\n          if (changedNormals[i] === false) {\n            for (let j = 0; j < 3; j++) geometry.attributes.normal.array[3 * i + j] = oldNormals[3 * i + j];\n          }\n        }\n      }\n    }\n    return geometry;\n  }\n}\nexport { EdgeSplitModifier };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}