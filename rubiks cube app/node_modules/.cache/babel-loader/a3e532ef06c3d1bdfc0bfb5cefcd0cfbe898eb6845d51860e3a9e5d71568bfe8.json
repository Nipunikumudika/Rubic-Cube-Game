{"ast":null,"code":"// import React, { useRef, useEffect, useState } from \"react\";\n// // import { OrbitControls } from \"@react-three/drei\";\n// import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\n// import { Canvas, useThree } from \"react-three-fiber\";\n\n// const RubiksCubeModel = ({ nodesSubset }) => {\n\n//   const cubeRefs = useRef([]);\n//   const startYRef = useRef(0);\n//   const initialRotation = [Math.PI / 6, Math.PI / 4, 0];\n//   const groupRef = useRef();\n\n//   let controls;\n\n//   const CameraController = () => {\n//     const { camera, gl } = useThree();\n\n//     useEffect(\n//       () => {\n//         controls = new OrbitControls(camera, gl.domElement);\n\n//         controls.minDistance = 3;\n//         controls.maxDistance = 20;\n//         return () => {\n//           controls.dispose();\n//         };\n//       },\n//       [camera, gl]\n//     );\n//     return null;\n//   };\n\n//   const handlePointerDown = (event) => {\n//     controls.enabled = false;\n//     controls.update();\n//     console.log(\"down\");\n//     startYRef.current = event.clientY;\n//     if (event.target.tagName === \"CANVAS\") {\n//       console.log(\"outside true\");\n//     } else {\n//       console.log(\"inside false\");\n//     }\n\n//     window.addEventListener(\"pointermove\", handlePointerMove);\n//     window.addEventListener(\"pointerup\", handlePointerUp);\n//     event.stopPropagation();\n//   };\n\n//   let deltaY;\n\n//   const handlePointerMove = (event) => {\n//     console.log(\"move\");\n//     const startY = startYRef.current;\n//     if (startY !== null) {\n//       deltaY = event.clientY - startY;\n//     }\n//   };\n\n//   let targetRot = 0;\n\n//   const handlePointerUp = async () => {\n//     console.log(\"up\");\n//     window.removeEventListener(\"pointermove\", handlePointerMove);\n//     window.removeEventListener(\"pointerup\", handlePointerUp);\n//     if (deltaY > 0) {\n//       cubeRefs.current.forEach((cubeRef, index) => {\n//         targetRot = cubeRef.current.rotation.z + Math.PI / 2;\n//       });\n\n//       DraggingDown();\n//       // controls.enableRotate = true;\n//       deltaY = 0;\n//     } else if (deltaY < 0) {\n//       cubeRefs.current.forEach((cubeRef, index) => {\n//         targetRot = cubeRef.current.rotation.z - Math.PI / 2;\n//         console.log(cubeRef.current.rotation.z);\n//       });\n\n//       DraggingUp();\n//       // controls.enableRotate = true;\n//       deltaY = 0;\n//     }\n//   };\n\n//   const DraggingDown = async () => {\n//     cubeRefs.current.forEach(async (cubeRef, index) => {\n//       while (Math.abs(cubeRef.current.rotation.z - targetRot) >= 0.001) {\n//         cubeRef.current.rotation.z += Math.PI / 10;\n//         await new Promise((resolve) => requestAnimationFrame(resolve));\n//         await new Promise((resolve) => setTimeout(resolve, 1));\n//       }\n//     });\n//   };\n\n//   const DraggingUp = async () => {\n//     cubeRefs.current.forEach(async (cubeRef, index) => {\n//       while (Math.abs(cubeRef.current.rotation.z - targetRot) >= 0.001) {\n//         cubeRef.current.rotation.z -= Math.PI / 10;\n//         await new Promise((resolve) => requestAnimationFrame(resolve));\n//         await new Promise((resolve) => setTimeout(resolve, 1));\n//       }\n//     });\n//   };\n\n//   return (\n//     <>\n\n//       <group\n//         ref={groupRef}\n//         scale={[0.3, 0.3, 0.3]}\n//         rotation={initialRotation}\n//         onPointerDown={handlePointerDown}\n//       >\n//         {nodesSubset.map((node, index) => (\n//           <primitive\n//             key={index}\n//             object={node}\n//             ref={(ref) => (cubeRefs.current[index] = { current: ref })}\n//           />\n//         ))}\n//       </group>\n//       <CameraController />\n//     </>\n//   );\n// };\n\n// export default RubiksCubeModel;\n\nimport * as THREE from 'three';\nimport CameraControls from 'camera-controls';\nCameraControls.install({\n  THREE: THREE\n});\n\n// snip ( init three scene... )\nconst clock = new THREE.Clock();\nconst camera = new THREE.PerspectiveCamera(60, width / height, 0.01, 1000);\nconst cameraControls = new CameraControls(camera, renderer.domElement);\n(function anim() {\n  // snip\n  const delta = clock.getDelta();\n  const hasControlsUpdated = cameraControls.update(delta);\n  requestAnimationFrame(anim);\n\n  // you can skip this condition to render though\n  if (hasControlsUpdated) {\n    renderer.render(scene, camera);\n  }\n})();","map":{"version":3,"names":["THREE","CameraControls","install","clock","Clock","camera","PerspectiveCamera","width","height","cameraControls","renderer","domElement","anim","delta","getDelta","hasControlsUpdated","update","requestAnimationFrame","render","scene"],"sources":["E:/projects/React rubik cube app/Rubic-Cube-Game/rubiks cube app/src/RubiksCubeModel.js"],"sourcesContent":["// import React, { useRef, useEffect, useState } from \"react\";\r\n// // import { OrbitControls } from \"@react-three/drei\";\r\n// import { OrbitControls } from \"three/examples/jsm/controls/OrbitControls\";\r\n// import { Canvas, useThree } from \"react-three-fiber\";\r\n\r\n// const RubiksCubeModel = ({ nodesSubset }) => {\r\n\r\n//   const cubeRefs = useRef([]);\r\n//   const startYRef = useRef(0);\r\n//   const initialRotation = [Math.PI / 6, Math.PI / 4, 0];\r\n//   const groupRef = useRef();\r\n\r\n//   let controls;\r\n\r\n//   const CameraController = () => {\r\n//     const { camera, gl } = useThree();\r\n    \r\n//     useEffect(\r\n//       () => {\r\n//         controls = new OrbitControls(camera, gl.domElement);\r\n  \r\n//         controls.minDistance = 3;\r\n//         controls.maxDistance = 20;\r\n//         return () => {\r\n//           controls.dispose();\r\n//         };\r\n//       },\r\n//       [camera, gl]\r\n//     );\r\n//     return null;\r\n//   };\r\n\r\n//   const handlePointerDown = (event) => {\r\n//     controls.enabled = false;\r\n//     controls.update();\r\n//     console.log(\"down\");\r\n//     startYRef.current = event.clientY;\r\n//     if (event.target.tagName === \"CANVAS\") {\r\n//       console.log(\"outside true\");\r\n//     } else {\r\n//       console.log(\"inside false\");\r\n//     }\r\n\r\n//     window.addEventListener(\"pointermove\", handlePointerMove);\r\n//     window.addEventListener(\"pointerup\", handlePointerUp);\r\n//     event.stopPropagation();\r\n//   };\r\n\r\n//   let deltaY;\r\n\r\n//   const handlePointerMove = (event) => {\r\n//     console.log(\"move\");\r\n//     const startY = startYRef.current;\r\n//     if (startY !== null) {\r\n//       deltaY = event.clientY - startY;\r\n//     }\r\n//   };\r\n\r\n//   let targetRot = 0;\r\n\r\n//   const handlePointerUp = async () => {\r\n//     console.log(\"up\");\r\n//     window.removeEventListener(\"pointermove\", handlePointerMove);\r\n//     window.removeEventListener(\"pointerup\", handlePointerUp);\r\n//     if (deltaY > 0) {\r\n//       cubeRefs.current.forEach((cubeRef, index) => {\r\n//         targetRot = cubeRef.current.rotation.z + Math.PI / 2;\r\n//       });\r\n\r\n//       DraggingDown();\r\n//       // controls.enableRotate = true;\r\n//       deltaY = 0;\r\n//     } else if (deltaY < 0) {\r\n//       cubeRefs.current.forEach((cubeRef, index) => {\r\n//         targetRot = cubeRef.current.rotation.z - Math.PI / 2;\r\n//         console.log(cubeRef.current.rotation.z);\r\n//       });\r\n\r\n//       DraggingUp();\r\n//       // controls.enableRotate = true;\r\n//       deltaY = 0;\r\n//     }\r\n//   };\r\n\r\n//   const DraggingDown = async () => {\r\n//     cubeRefs.current.forEach(async (cubeRef, index) => {\r\n//       while (Math.abs(cubeRef.current.rotation.z - targetRot) >= 0.001) {\r\n//         cubeRef.current.rotation.z += Math.PI / 10;\r\n//         await new Promise((resolve) => requestAnimationFrame(resolve));\r\n//         await new Promise((resolve) => setTimeout(resolve, 1));\r\n//       }\r\n//     });\r\n//   };\r\n\r\n//   const DraggingUp = async () => {\r\n//     cubeRefs.current.forEach(async (cubeRef, index) => {\r\n//       while (Math.abs(cubeRef.current.rotation.z - targetRot) >= 0.001) {\r\n//         cubeRef.current.rotation.z -= Math.PI / 10;\r\n//         await new Promise((resolve) => requestAnimationFrame(resolve));\r\n//         await new Promise((resolve) => setTimeout(resolve, 1));\r\n//       }\r\n//     });\r\n//   };\r\n\r\n//   return (\r\n//     <>\r\n\r\n//       <group\r\n//         ref={groupRef}\r\n//         scale={[0.3, 0.3, 0.3]}\r\n//         rotation={initialRotation}\r\n//         onPointerDown={handlePointerDown}\r\n//       >\r\n//         {nodesSubset.map((node, index) => (\r\n//           <primitive\r\n//             key={index}\r\n//             object={node}\r\n//             ref={(ref) => (cubeRefs.current[index] = { current: ref })}\r\n//           />\r\n//         ))}\r\n//       </group>\r\n//       <CameraController />\r\n//     </>\r\n//   );\r\n// };\r\n\r\n// export default RubiksCubeModel;\r\n\r\nimport * as THREE from 'three';\r\nimport CameraControls from 'camera-controls';\r\n\r\nCameraControls.install( { THREE: THREE } );\r\n\r\n// snip ( init three scene... )\r\nconst clock = new THREE.Clock();\r\nconst camera = new THREE.PerspectiveCamera( 60, width / height, 0.01, 1000 );\r\nconst cameraControls = new CameraControls( camera, renderer.domElement );\r\n\r\n( function anim () {\r\n\r\n\t// snip\r\n\tconst delta = clock.getDelta();\r\n\tconst hasControlsUpdated = cameraControls.update( delta );\r\n\r\n\trequestAnimationFrame( anim );\r\n\r\n\t// you can skip this condition to render though\r\n\tif ( hasControlsUpdated ) {\r\n\r\n\t\trenderer.render( scene, camera );\r\n\r\n\t}\r\n\r\n} )();"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,OAAO,KAAKA,KAAK,MAAM,OAAO;AAC9B,OAAOC,cAAc,MAAM,iBAAiB;AAE5CA,cAAc,CAACC,OAAO,CAAE;EAAEF,KAAK,EAAEA;AAAM,CAAE,CAAC;;AAE1C;AACA,MAAMG,KAAK,GAAG,IAAIH,KAAK,CAACI,KAAK,CAAC,CAAC;AAC/B,MAAMC,MAAM,GAAG,IAAIL,KAAK,CAACM,iBAAiB,CAAE,EAAE,EAAEC,KAAK,GAAGC,MAAM,EAAE,IAAI,EAAE,IAAK,CAAC;AAC5E,MAAMC,cAAc,GAAG,IAAIR,cAAc,CAAEI,MAAM,EAAEK,QAAQ,CAACC,UAAW,CAAC;AAExE,CAAE,SAASC,IAAIA,CAAA,EAAI;EAElB;EACA,MAAMC,KAAK,GAAGV,KAAK,CAACW,QAAQ,CAAC,CAAC;EAC9B,MAAMC,kBAAkB,GAAGN,cAAc,CAACO,MAAM,CAAEH,KAAM,CAAC;EAEzDI,qBAAqB,CAAEL,IAAK,CAAC;;EAE7B;EACA,IAAKG,kBAAkB,EAAG;IAEzBL,QAAQ,CAACQ,MAAM,CAAEC,KAAK,EAAEd,MAAO,CAAC;EAEjC;AAED,CAAC,EAAG,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}