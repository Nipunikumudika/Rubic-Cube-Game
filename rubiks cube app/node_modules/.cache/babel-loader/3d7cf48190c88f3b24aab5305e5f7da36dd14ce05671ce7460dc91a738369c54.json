{"ast":null,"code":"import { Face3, Geometry, Vector2, Vector3 } from \"../../../build/three.module.js\";\n/**\n *\tSubdivision Geometry Modifier\n *\t\tusing Loop Subdivision Scheme\n *\n *\tReferences:\n *\t\thttp://graphics.stanford.edu/~mdfisher/subdivision.html\n *\t\thttp://www.holmes3d.net/graphics/subdivision/\n *\t\thttp://www.cs.rutgers.edu/~decarlo/readings/subdiv-sg00c.pdf\n *\n *\tKnown Issues:\n *\t\t- currently doesn't handle \"Sharp Edges\"\n */\n\nvar SubdivisionModifier = function (subdivisions) {\n  this.subdivisions = subdivisions === undefined ? 1 : subdivisions;\n};\n\n// Applies the \"modify\" pattern\nSubdivisionModifier.prototype.modify = function (geometry) {\n  if (geometry.isBufferGeometry) {\n    geometry = new Geometry().fromBufferGeometry(geometry);\n  } else {\n    geometry = geometry.clone();\n  }\n  geometry.mergeVertices();\n  var repeats = this.subdivisions;\n  while (repeats-- > 0) {\n    this.smooth(geometry);\n  }\n  geometry.computeFaceNormals();\n  geometry.computeVertexNormals();\n  return geometry;\n};\n(function () {\n  // Some constants\n  var ABC = ['a', 'b', 'c'];\n  function getEdge(a, b, map) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    return map[key];\n  }\n  function processEdge(a, b, vertices, map, face, metaVertices) {\n    var vertexIndexA = Math.min(a, b);\n    var vertexIndexB = Math.max(a, b);\n    var key = vertexIndexA + \"_\" + vertexIndexB;\n    var edge;\n    if (key in map) {\n      edge = map[key];\n    } else {\n      var vertexA = vertices[vertexIndexA];\n      var vertexB = vertices[vertexIndexB];\n      edge = {\n        a: vertexA,\n        // pointer reference\n        b: vertexB,\n        newEdge: null,\n        // aIndex: a, // numbered reference\n        // bIndex: b,\n        faces: [] // pointers to face\n      };\n      map[key] = edge;\n    }\n    edge.faces.push(face);\n    metaVertices[a].edges.push(edge);\n    metaVertices[b].edges.push(edge);\n  }\n  function generateLookups(vertices, faces, metaVertices, edges) {\n    var i, il, face;\n    for (i = 0, il = vertices.length; i < il; i++) {\n      metaVertices[i] = {\n        edges: []\n      };\n    }\n    for (i = 0, il = faces.length; i < il; i++) {\n      face = faces[i];\n      processEdge(face.a, face.b, vertices, edges, face, metaVertices);\n      processEdge(face.b, face.c, vertices, edges, face, metaVertices);\n      processEdge(face.c, face.a, vertices, edges, face, metaVertices);\n    }\n  }\n  function newFace(newFaces, a, b, c, materialIndex) {\n    newFaces.push(new Face3(a, b, c, undefined, undefined, materialIndex));\n  }\n  function midpoint(a, b) {\n    return Math.abs(b - a) / 2 + Math.min(a, b);\n  }\n  function newUv(newUvs, a, b, c) {\n    newUvs.push([a.clone(), b.clone(), c.clone()]);\n  }\n\n  /////////////////////////////\n\n  // Performs one iteration of Subdivision\n  SubdivisionModifier.prototype.smooth = function (geometry) {\n    var tmp = new Vector3();\n    var oldVertices, oldFaces, oldUvs;\n    var newVertices,\n      newFaces,\n      newUVs = [];\n    var n, i, il, j, k;\n    var metaVertices, sourceEdges;\n\n    // new stuff.\n    var sourceEdges, newEdgeVertices, newSourceVertices;\n    oldVertices = geometry.vertices; // { x, y, z}\n    oldFaces = geometry.faces; // { a: oldVertex1, b: oldVertex2, c: oldVertex3 }\n    oldUvs = geometry.faceVertexUvs;\n    var hasUvs = oldUvs[0] !== undefined && oldUvs[0].length > 0;\n    if (hasUvs) {\n      for (var j = 0; j < oldUvs.length; j++) {\n        newUVs.push([]);\n      }\n    }\n\n    /******************************************************\n     *\n     * Step 0: Preprocess Geometry to Generate edges Lookup\n     *\n     *******************************************************/\n\n    metaVertices = new Array(oldVertices.length);\n    sourceEdges = {}; // Edge => { oldVertex1, oldVertex2, faces[]  }\n\n    generateLookups(oldVertices, oldFaces, metaVertices, sourceEdges);\n\n    /******************************************************\n     *\n     *\tStep 1.\n     *\tFor each edge, create a new Edge Vertex,\n     *\tthen position it.\n     *\n     *******************************************************/\n\n    newEdgeVertices = [];\n    var other, currentEdge, newEdge, face;\n    var edgeVertexWeight, adjacentVertexWeight, connectedFaces;\n    for (i in sourceEdges) {\n      currentEdge = sourceEdges[i];\n      newEdge = new Vector3();\n      edgeVertexWeight = 3 / 8;\n      adjacentVertexWeight = 1 / 8;\n      connectedFaces = currentEdge.faces.length;\n\n      // check how many linked faces. 2 should be correct.\n      if (connectedFaces != 2) {\n        // if length is not 2, handle condition\n        edgeVertexWeight = 0.5;\n        adjacentVertexWeight = 0;\n        if (connectedFaces != 1) {\n\n          // console.warn( 'Subdivision Modifier: Number of connected faces != 2, is: ', connectedFaces, currentEdge );\n        }\n      }\n      newEdge.addVectors(currentEdge.a, currentEdge.b).multiplyScalar(edgeVertexWeight);\n      tmp.set(0, 0, 0);\n      for (j = 0; j < connectedFaces; j++) {\n        face = currentEdge.faces[j];\n        for (k = 0; k < 3; k++) {\n          other = oldVertices[face[ABC[k]]];\n          if (other !== currentEdge.a && other !== currentEdge.b) break;\n        }\n        tmp.add(other);\n      }\n      tmp.multiplyScalar(adjacentVertexWeight);\n      newEdge.add(tmp);\n      currentEdge.newEdge = newEdgeVertices.length;\n      newEdgeVertices.push(newEdge);\n\n      // console.log(currentEdge, newEdge);\n    }\n\n    /******************************************************\n     *\n     *\tStep 2.\n     *\tReposition each source vertices.\n     *\n     *******************************************************/\n\n    var beta, sourceVertexWeight, connectingVertexWeight;\n    var connectingEdge, connectingEdges, oldVertex, newSourceVertex;\n    newSourceVertices = [];\n    for (i = 0, il = oldVertices.length; i < il; i++) {\n      oldVertex = oldVertices[i];\n\n      // find all connecting edges (using lookupTable)\n      connectingEdges = metaVertices[i].edges;\n      n = connectingEdges.length;\n      if (n == 3) {\n        beta = 3 / 16;\n      } else if (n > 3) {\n        beta = 3 / (8 * n); // Warren's modified formula\n      }\n\n      // Loop's original beta formula\n      // beta = 1 / n * ( 5/8 - Math.pow( 3/8 + 1/4 * Math.cos( 2 * Math. PI / n ), 2) );\n\n      sourceVertexWeight = 1 - n * beta;\n      connectingVertexWeight = beta;\n      if (n <= 2) {\n        // crease and boundary rules\n        // console.warn('crease and boundary rules');\n\n        if (n == 2) {\n          // console.warn( '2 connecting edges', connectingEdges );\n          sourceVertexWeight = 3 / 4;\n          connectingVertexWeight = 1 / 8;\n\n          // sourceVertexWeight = 1;\n          // connectingVertexWeight = 0;\n        } else if (n == 1) {\n\n          // console.warn( 'only 1 connecting edge' );\n        } else if (n == 0) {\n\n          // console.warn( '0 connecting edges' );\n        }\n      }\n      newSourceVertex = oldVertex.clone().multiplyScalar(sourceVertexWeight);\n      tmp.set(0, 0, 0);\n      for (j = 0; j < n; j++) {\n        connectingEdge = connectingEdges[j];\n        other = connectingEdge.a !== oldVertex ? connectingEdge.a : connectingEdge.b;\n        tmp.add(other);\n      }\n      tmp.multiplyScalar(connectingVertexWeight);\n      newSourceVertex.add(tmp);\n      newSourceVertices.push(newSourceVertex);\n    }\n\n    /******************************************************\n     *\n     *\tStep 3.\n     *\tGenerate Faces between source vertices\n     *\tand edge vertices.\n     *\n     *******************************************************/\n\n    newVertices = newSourceVertices.concat(newEdgeVertices);\n    var sl = newSourceVertices.length,\n      edge1,\n      edge2,\n      edge3;\n    newFaces = [];\n    var uv, x0, x1, x2;\n    var x3 = new Vector2();\n    var x4 = new Vector2();\n    var x5 = new Vector2();\n    for (i = 0, il = oldFaces.length; i < il; i++) {\n      face = oldFaces[i];\n\n      // find the 3 new edges vertex of each old face\n\n      edge1 = getEdge(face.a, face.b, sourceEdges).newEdge + sl;\n      edge2 = getEdge(face.b, face.c, sourceEdges).newEdge + sl;\n      edge3 = getEdge(face.c, face.a, sourceEdges).newEdge + sl;\n\n      // create 4 faces.\n\n      newFace(newFaces, edge1, edge2, edge3, face.materialIndex);\n      newFace(newFaces, face.a, edge1, edge3, face.materialIndex);\n      newFace(newFaces, face.b, edge2, edge1, face.materialIndex);\n      newFace(newFaces, face.c, edge3, edge2, face.materialIndex);\n\n      // create 4 new uv's\n\n      if (hasUvs) {\n        for (var j = 0; j < oldUvs.length; j++) {\n          uv = oldUvs[j][i];\n          x0 = uv[0];\n          x1 = uv[1];\n          x2 = uv[2];\n          x3.set(midpoint(x0.x, x1.x), midpoint(x0.y, x1.y));\n          x4.set(midpoint(x1.x, x2.x), midpoint(x1.y, x2.y));\n          x5.set(midpoint(x0.x, x2.x), midpoint(x0.y, x2.y));\n          newUv(newUVs[j], x3, x4, x5);\n          newUv(newUVs[j], x0, x3, x5);\n          newUv(newUVs[j], x1, x4, x3);\n          newUv(newUVs[j], x2, x5, x4);\n        }\n      }\n    }\n\n    // Overwrite old arrays\n    geometry.vertices = newVertices;\n    geometry.faces = newFaces;\n    if (hasUvs) geometry.faceVertexUvs = newUVs;\n\n    // console.log('done');\n  };\n})();\nexport { SubdivisionModifier };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}