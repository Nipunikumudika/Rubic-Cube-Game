{"ast":null,"code":"import { Vector3, Vector4 } from \"../../../build/three.module.js\";\n/**\n * NURBS utils\n *\n * See NURBSCurve and NURBSSurface.\n **/\n\n/**************************************************************\n *\tNURBS Utils\n **************************************************************/\n\nvar NURBSUtils = {\n  /*\n  Finds knot vector span.\n  \tp : degree\n  u : parametric value\n  U : knot vector\n  \treturns the span\n  */\n  findSpan: function (p, u, U) {\n    var n = U.length - p - 1;\n    if (u >= U[n]) {\n      return n - 1;\n    }\n    if (u <= U[p]) {\n      return p;\n    }\n    var low = p;\n    var high = n;\n    var mid = Math.floor((low + high) / 2);\n    while (u < U[mid] || u >= U[mid + 1]) {\n      if (u < U[mid]) {\n        high = mid;\n      } else {\n        low = mid;\n      }\n      mid = Math.floor((low + high) / 2);\n    }\n    return mid;\n  },\n  /*\n  Calculate basis functions. See The NURBS Book, page 70, algorithm A2.2\n  \tspan : span in which u lies\n  u    : parametric point\n  p    : degree\n  U    : knot vector\n  \treturns array[p+1] with basis functions values.\n  */\n  calcBasisFunctions: function (span, u, p, U) {\n    var N = [];\n    var left = [];\n    var right = [];\n    N[0] = 1.0;\n    for (var j = 1; j <= p; ++j) {\n      left[j] = u - U[span + 1 - j];\n      right[j] = U[span + j] - u;\n      var saved = 0.0;\n      for (var r = 0; r < j; ++r) {\n        var rv = right[r + 1];\n        var lv = left[j - r];\n        var temp = N[r] / (rv + lv);\n        N[r] = saved + rv * temp;\n        saved = lv * temp;\n      }\n      N[j] = saved;\n    }\n    return N;\n  },\n  /*\n  Calculate B-Spline curve points. See The NURBS Book, page 82, algorithm A3.1.\n  \tp : degree of B-Spline\n  U : knot vector\n  P : control points (x, y, z, w)\n  u : parametric point\n  \treturns point for given u\n  */\n  calcBSplinePoint: function (p, U, P, u) {\n    var span = this.findSpan(p, u, U);\n    var N = this.calcBasisFunctions(span, u, p, U);\n    var C = new Vector4(0, 0, 0, 0);\n    for (var j = 0; j <= p; ++j) {\n      var point = P[span - p + j];\n      var Nj = N[j];\n      var wNj = point.w * Nj;\n      C.x += point.x * wNj;\n      C.y += point.y * wNj;\n      C.z += point.z * wNj;\n      C.w += point.w * Nj;\n    }\n    return C;\n  },\n  /*\n  Calculate basis functions derivatives. See The NURBS Book, page 72, algorithm A2.3.\n  \tspan : span in which u lies\n  u    : parametric point\n  p    : degree\n  n    : number of derivatives to calculate\n  U    : knot vector\n  \treturns array[n+1][p+1] with basis functions derivatives\n  */\n  calcBasisFunctionDerivatives: function (span, u, p, n, U) {\n    var zeroArr = [];\n    for (var i = 0; i <= p; ++i) zeroArr[i] = 0.0;\n    var ders = [];\n    for (var i = 0; i <= n; ++i) ders[i] = zeroArr.slice(0);\n    var ndu = [];\n    for (var i = 0; i <= p; ++i) ndu[i] = zeroArr.slice(0);\n    ndu[0][0] = 1.0;\n    var left = zeroArr.slice(0);\n    var right = zeroArr.slice(0);\n    for (var j = 1; j <= p; ++j) {\n      left[j] = u - U[span + 1 - j];\n      right[j] = U[span + j] - u;\n      var saved = 0.0;\n      for (var r = 0; r < j; ++r) {\n        var rv = right[r + 1];\n        var lv = left[j - r];\n        ndu[j][r] = rv + lv;\n        var temp = ndu[r][j - 1] / ndu[j][r];\n        ndu[r][j] = saved + rv * temp;\n        saved = lv * temp;\n      }\n      ndu[j][j] = saved;\n    }\n    for (var j = 0; j <= p; ++j) {\n      ders[0][j] = ndu[j][p];\n    }\n    for (var r = 0; r <= p; ++r) {\n      var s1 = 0;\n      var s2 = 1;\n      var a = [];\n      for (var i = 0; i <= p; ++i) {\n        a[i] = zeroArr.slice(0);\n      }\n      a[0][0] = 1.0;\n      for (var k = 1; k <= n; ++k) {\n        var d = 0.0;\n        var rk = r - k;\n        var pk = p - k;\n        if (r >= k) {\n          a[s2][0] = a[s1][0] / ndu[pk + 1][rk];\n          d = a[s2][0] * ndu[rk][pk];\n        }\n        var j1 = rk >= -1 ? 1 : -rk;\n        var j2 = r - 1 <= pk ? k - 1 : p - r;\n        for (var j = j1; j <= j2; ++j) {\n          a[s2][j] = (a[s1][j] - a[s1][j - 1]) / ndu[pk + 1][rk + j];\n          d += a[s2][j] * ndu[rk + j][pk];\n        }\n        if (r <= pk) {\n          a[s2][k] = -a[s1][k - 1] / ndu[pk + 1][r];\n          d += a[s2][k] * ndu[r][pk];\n        }\n        ders[k][r] = d;\n        var j = s1;\n        s1 = s2;\n        s2 = j;\n      }\n    }\n    var r = p;\n    for (var k = 1; k <= n; ++k) {\n      for (var j = 0; j <= p; ++j) {\n        ders[k][j] *= r;\n      }\n      r *= p - k;\n    }\n    return ders;\n  },\n  /*\n  \tCalculate derivatives of a B-Spline. See The NURBS Book, page 93, algorithm A3.2.\n  \t\tp  : degree\n  \tU  : knot vector\n  \tP  : control points\n  \tu  : Parametric points\n  \tnd : number of derivatives\n  \t\treturns array[d+1] with derivatives\n  \t*/\n  calcBSplineDerivatives: function (p, U, P, u, nd) {\n    var du = nd < p ? nd : p;\n    var CK = [];\n    var span = this.findSpan(p, u, U);\n    var nders = this.calcBasisFunctionDerivatives(span, u, p, du, U);\n    var Pw = [];\n    for (var i = 0; i < P.length; ++i) {\n      var point = P[i].clone();\n      var w = point.w;\n      point.x *= w;\n      point.y *= w;\n      point.z *= w;\n      Pw[i] = point;\n    }\n    for (var k = 0; k <= du; ++k) {\n      var point = Pw[span - p].clone().multiplyScalar(nders[k][0]);\n      for (var j = 1; j <= p; ++j) {\n        point.add(Pw[span - p + j].clone().multiplyScalar(nders[k][j]));\n      }\n      CK[k] = point;\n    }\n    for (var k = du + 1; k <= nd + 1; ++k) {\n      CK[k] = new Vector4(0, 0, 0);\n    }\n    return CK;\n  },\n  /*\n  Calculate \"K over I\"\n  \treturns k!/(i!(k-i)!)\n  */\n  calcKoverI: function (k, i) {\n    var nom = 1;\n    for (var j = 2; j <= k; ++j) {\n      nom *= j;\n    }\n    var denom = 1;\n    for (var j = 2; j <= i; ++j) {\n      denom *= j;\n    }\n    for (var j = 2; j <= k - i; ++j) {\n      denom *= j;\n    }\n    return nom / denom;\n  },\n  /*\n  Calculate derivatives (0-nd) of rational curve. See The NURBS Book, page 127, algorithm A4.2.\n  \tPders : result of function calcBSplineDerivatives\n  \treturns array with derivatives for rational curve.\n  */\n  calcRationalCurveDerivatives: function (Pders) {\n    var nd = Pders.length;\n    var Aders = [];\n    var wders = [];\n    for (var i = 0; i < nd; ++i) {\n      var point = Pders[i];\n      Aders[i] = new Vector3(point.x, point.y, point.z);\n      wders[i] = point.w;\n    }\n    var CK = [];\n    for (var k = 0; k < nd; ++k) {\n      var v = Aders[k].clone();\n      for (var i = 1; i <= k; ++i) {\n        v.sub(CK[k - i].clone().multiplyScalar(this.calcKoverI(k, i) * wders[i]));\n      }\n      CK[k] = v.divideScalar(wders[0]);\n    }\n    return CK;\n  },\n  /*\n  Calculate NURBS curve derivatives. See The NURBS Book, page 127, algorithm A4.2.\n  \tp  : degree\n  U  : knot vector\n  P  : control points in homogeneous space\n  u  : parametric points\n  nd : number of derivatives\n  \treturns array with derivatives.\n  */\n  calcNURBSDerivatives: function (p, U, P, u, nd) {\n    var Pders = this.calcBSplineDerivatives(p, U, P, u, nd);\n    return this.calcRationalCurveDerivatives(Pders);\n  },\n  /*\n  Calculate rational B-Spline surface point. See The NURBS Book, page 134, algorithm A4.3.\n  \tp1, p2 : degrees of B-Spline surface\n  U1, U2 : knot vectors\n  P      : control points (x, y, z, w)\n  u, v   : parametric values\n  \treturns point for given (u, v)\n  */\n  calcSurfacePoint: function (p, q, U, V, P, u, v, target) {\n    var uspan = this.findSpan(p, u, U);\n    var vspan = this.findSpan(q, v, V);\n    var Nu = this.calcBasisFunctions(uspan, u, p, U);\n    var Nv = this.calcBasisFunctions(vspan, v, q, V);\n    var temp = [];\n    for (var l = 0; l <= q; ++l) {\n      temp[l] = new Vector4(0, 0, 0, 0);\n      for (var k = 0; k <= p; ++k) {\n        var point = P[uspan - p + k][vspan - q + l].clone();\n        var w = point.w;\n        point.x *= w;\n        point.y *= w;\n        point.z *= w;\n        temp[l].add(point.multiplyScalar(Nu[k]));\n      }\n    }\n    var Sw = new Vector4(0, 0, 0, 0);\n    for (var l = 0; l <= q; ++l) {\n      Sw.add(temp[l].multiplyScalar(Nv[l]));\n    }\n    Sw.divideScalar(Sw.w);\n    target.set(Sw.x, Sw.y, Sw.z);\n  }\n};\nexport { NURBSUtils };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}