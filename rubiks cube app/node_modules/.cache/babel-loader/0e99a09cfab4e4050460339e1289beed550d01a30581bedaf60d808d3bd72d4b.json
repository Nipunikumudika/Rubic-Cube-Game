{"ast":null,"code":"import { BufferGeometry, Float32BufferAttribute, Geometry, Vector3 } from \"../../../build/three.module.js\";\n/**\n *\tSimplification Geometry Modifier\n *    - based on code and technique\n *\t  - by Stan Melax in 1998\n *\t  - Progressive Mesh type Polygon Reduction Algorithm\n *    - http://www.melax.com/polychop/\n */\n\nvar SimplifyModifier = function () {};\n(function () {\n  var cb = new Vector3(),\n    ab = new Vector3();\n  function pushIfUnique(array, object) {\n    if (array.indexOf(object) === -1) array.push(object);\n  }\n  function removeFromArray(array, object) {\n    var k = array.indexOf(object);\n    if (k > -1) array.splice(k, 1);\n  }\n  function computeEdgeCollapseCost(u, v) {\n    // if we collapse edge uv by moving u to v then how\n    // much different will the model change, i.e. the \"error\".\n\n    var edgelength = v.position.distanceTo(u.position);\n    var curvature = 0;\n    var sideFaces = [];\n    var i,\n      il = u.faces.length,\n      face,\n      sideFace;\n\n    // find the \"sides\" triangles that are on the edge uv\n    for (i = 0; i < il; i++) {\n      face = u.faces[i];\n      if (face.hasVertex(v)) {\n        sideFaces.push(face);\n      }\n    }\n\n    // use the triangle facing most away from the sides\n    // to determine our curvature term\n    for (i = 0; i < il; i++) {\n      var minCurvature = 1;\n      face = u.faces[i];\n      for (var j = 0; j < sideFaces.length; j++) {\n        sideFace = sideFaces[j];\n        // use dot product of face normals.\n        var dotProd = face.normal.dot(sideFace.normal);\n        minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);\n      }\n      curvature = Math.max(curvature, minCurvature);\n    }\n\n    // crude approach in attempt to preserve borders\n    // though it seems not to be totally correct\n    var borders = 0;\n    if (sideFaces.length < 2) {\n      // we add some arbitrary cost for borders,\n      // borders += 10;\n      curvature = 1;\n    }\n    var amt = edgelength * curvature + borders;\n    return amt;\n  }\n  function computeEdgeCostAtVertex(v) {\n    // compute the edge collapse cost for all edges that start\n    // from vertex v.  Since we are only interested in reducing\n    // the object by selecting the min cost edge at each step, we\n    // only cache the cost of the least cost edge at this vertex\n    // (in member variable collapse) as well as the value of the\n    // cost (in member variable collapseCost).\n\n    if (v.neighbors.length === 0) {\n      // collapse if no neighbors.\n      v.collapseNeighbor = null;\n      v.collapseCost = -0.01;\n      return;\n    }\n    v.collapseCost = 100000;\n    v.collapseNeighbor = null;\n\n    // search all neighboring edges for \"least cost\" edge\n    for (var i = 0; i < v.neighbors.length; i++) {\n      var collapseCost = computeEdgeCollapseCost(v, v.neighbors[i]);\n      if (!v.collapseNeighbor) {\n        v.collapseNeighbor = v.neighbors[i];\n        v.collapseCost = collapseCost;\n        v.minCost = collapseCost;\n        v.totalCost = 0;\n        v.costCount = 0;\n      }\n      v.costCount++;\n      v.totalCost += collapseCost;\n      if (collapseCost < v.minCost) {\n        v.collapseNeighbor = v.neighbors[i];\n        v.minCost = collapseCost;\n      }\n    }\n\n    // we average the cost of collapsing at this vertex\n    v.collapseCost = v.totalCost / v.costCount;\n    // v.collapseCost = v.minCost;\n  }\n  function removeVertex(v, vertices) {\n    console.assert(v.faces.length === 0);\n    while (v.neighbors.length) {\n      var n = v.neighbors.pop();\n      removeFromArray(n.neighbors, v);\n    }\n    removeFromArray(vertices, v);\n  }\n  function removeFace(f, faces) {\n    removeFromArray(faces, f);\n    if (f.v1) removeFromArray(f.v1.faces, f);\n    if (f.v2) removeFromArray(f.v2.faces, f);\n    if (f.v3) removeFromArray(f.v3.faces, f);\n\n    // TODO optimize this!\n    var vs = [f.v1, f.v2, f.v3];\n    var v1, v2;\n    for (var i = 0; i < 3; i++) {\n      v1 = vs[i];\n      v2 = vs[(i + 1) % 3];\n      if (!v1 || !v2) continue;\n      v1.removeIfNonNeighbor(v2);\n      v2.removeIfNonNeighbor(v1);\n    }\n  }\n  function collapse(vertices, faces, u, v) {\n    // u and v are pointers to vertices of an edge\n\n    // Collapse the edge uv by moving vertex u onto v\n\n    if (!v) {\n      // u is a vertex all by itself so just delete it..\n      removeVertex(u, vertices);\n      return;\n    }\n    var i;\n    var tmpVertices = [];\n    for (i = 0; i < u.neighbors.length; i++) {\n      tmpVertices.push(u.neighbors[i]);\n    }\n\n    // delete triangles on edge uv:\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      if (u.faces[i].hasVertex(v)) {\n        removeFace(u.faces[i], faces);\n      }\n    }\n\n    // update remaining triangles to have v instead of u\n    for (i = u.faces.length - 1; i >= 0; i--) {\n      u.faces[i].replaceVertex(u, v);\n    }\n    removeVertex(u, vertices);\n\n    // recompute the edge collapse costs in neighborhood\n    for (i = 0; i < tmpVertices.length; i++) {\n      computeEdgeCostAtVertex(tmpVertices[i]);\n    }\n  }\n  function minimumCostEdge(vertices) {\n    // O(n * n) approach. TODO optimize this\n\n    var least = vertices[0];\n    for (var i = 0; i < vertices.length; i++) {\n      if (vertices[i].collapseCost < least.collapseCost) {\n        least = vertices[i];\n      }\n    }\n    return least;\n  }\n\n  // we use a triangle class to represent structure of face slightly differently\n\n  function Triangle(v1, v2, v3, a, b, c) {\n    this.a = a;\n    this.b = b;\n    this.c = c;\n    this.v1 = v1;\n    this.v2 = v2;\n    this.v3 = v3;\n    this.normal = new Vector3();\n    this.computeNormal();\n    v1.faces.push(this);\n    v1.addUniqueNeighbor(v2);\n    v1.addUniqueNeighbor(v3);\n    v2.faces.push(this);\n    v2.addUniqueNeighbor(v1);\n    v2.addUniqueNeighbor(v3);\n    v3.faces.push(this);\n    v3.addUniqueNeighbor(v1);\n    v3.addUniqueNeighbor(v2);\n  }\n  Triangle.prototype.computeNormal = function () {\n    var vA = this.v1.position;\n    var vB = this.v2.position;\n    var vC = this.v3.position;\n    cb.subVectors(vC, vB);\n    ab.subVectors(vA, vB);\n    cb.cross(ab).normalize();\n    this.normal.copy(cb);\n  };\n  Triangle.prototype.hasVertex = function (v) {\n    return v === this.v1 || v === this.v2 || v === this.v3;\n  };\n  Triangle.prototype.replaceVertex = function (oldv, newv) {\n    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;\n    removeFromArray(oldv.faces, this);\n    newv.faces.push(this);\n    oldv.removeIfNonNeighbor(this.v1);\n    this.v1.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v2);\n    this.v2.removeIfNonNeighbor(oldv);\n    oldv.removeIfNonNeighbor(this.v3);\n    this.v3.removeIfNonNeighbor(oldv);\n    this.v1.addUniqueNeighbor(this.v2);\n    this.v1.addUniqueNeighbor(this.v3);\n    this.v2.addUniqueNeighbor(this.v1);\n    this.v2.addUniqueNeighbor(this.v3);\n    this.v3.addUniqueNeighbor(this.v1);\n    this.v3.addUniqueNeighbor(this.v2);\n    this.computeNormal();\n  };\n  function Vertex(v, id) {\n    this.position = v;\n    this.id = id; // old index id\n\n    this.faces = []; // faces vertex is connected\n    this.neighbors = []; // neighbouring vertices aka \"adjacentVertices\"\n\n    // these will be computed in computeEdgeCostAtVertex()\n    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist\n    this.collapseNeighbor = null; // best candinate for collapsing\n  }\n  Vertex.prototype.addUniqueNeighbor = function (vertex) {\n    pushIfUnique(this.neighbors, vertex);\n  };\n  Vertex.prototype.removeIfNonNeighbor = function (n) {\n    var neighbors = this.neighbors;\n    var faces = this.faces;\n    var offset = neighbors.indexOf(n);\n    if (offset === -1) return;\n    for (var i = 0; i < faces.length; i++) {\n      if (faces[i].hasVertex(n)) return;\n    }\n    neighbors.splice(offset, 1);\n  };\n  SimplifyModifier.prototype.modify = function (geometry, count) {\n    if (geometry.isBufferGeometry) {\n      geometry = new Geometry().fromBufferGeometry(geometry);\n    }\n    geometry.mergeVertices();\n    var oldVertices = geometry.vertices; // Three Position\n    var oldFaces = geometry.faces; // Three Face\n\n    // conversion\n    var vertices = [];\n    var faces = [];\n    var i, il;\n\n    //\n    // put data of original geometry in different data structures\n    //\n\n    // add vertices\n\n    for (i = 0, il = oldVertices.length; i < il; i++) {\n      var vertex = new Vertex(oldVertices[i], i);\n      vertices.push(vertex);\n    }\n\n    // add faces\n\n    for (i = 0, il = oldFaces.length; i < il; i++) {\n      var face = oldFaces[i];\n      var a = face.a;\n      var b = face.b;\n      var c = face.c;\n      var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);\n      faces.push(triangle);\n    }\n\n    // compute all edge collapse costs\n\n    for (i = 0, il = vertices.length; i < il; i++) {\n      computeEdgeCostAtVertex(vertices[i]);\n    }\n    var nextVertex;\n    var z = count;\n    while (z--) {\n      nextVertex = minimumCostEdge(vertices);\n      if (!nextVertex) {\n        console.log('THREE.SimplifyModifier: No next vertex');\n        break;\n      }\n      collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);\n    }\n\n    //\n\n    var simplifiedGeometry = new BufferGeometry();\n    var position = [];\n    var index = [];\n\n    //\n\n    for (i = 0; i < vertices.length; i++) {\n      var vertex = vertices[i].position;\n      position.push(vertex.x, vertex.y, vertex.z);\n    }\n\n    //\n\n    for (i = 0; i < faces.length; i++) {\n      var face = faces[i];\n      var a = vertices.indexOf(face.v1);\n      var b = vertices.indexOf(face.v2);\n      var c = vertices.indexOf(face.v3);\n      index.push(a, b, c);\n    }\n\n    //\n\n    simplifiedGeometry.setAttribute('position', new Float32BufferAttribute(position, 3));\n    simplifiedGeometry.setIndex(index);\n    return simplifiedGeometry;\n  };\n})();\nexport { SimplifyModifier };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}