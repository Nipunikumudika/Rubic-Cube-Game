{"ast":null,"code":"import { ShaderChunk, MathUtils, UniformsUtils, MeshDepthMaterial, RGBADepthPacking, MeshDistanceMaterial, ShaderLib, DataTexture, Vector3, Mesh, CylinderBufferGeometry, Vector2, MeshStandardMaterial, DoubleSide } from 'three';\n\n/**\r\n * Regular expression for matching the `void main() {` opener line in GLSL.\r\n * @type {RegExp}\r\n */\nconst voidMainRegExp = /\\bvoid\\s+main\\s*\\(\\s*\\)\\s*{/g;\n\n/**\r\n * Recursively expands all `#include <xyz>` statements within string of shader code.\r\n * Copied from three's WebGLProgram#parseIncludes for external use.\r\n *\r\n * @param {string} source - The GLSL source code to evaluate\r\n * @return {string} The GLSL code with all includes expanded\r\n */\nfunction expandShaderIncludes(source) {\n  const pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n  function replace(match, include) {\n    let chunk = ShaderChunk[include];\n    return chunk ? expandShaderIncludes(chunk) : match;\n  }\n  return source.replace(pattern, replace);\n}\n\n// Local assign polyfill to avoid importing troika-core\nconst assign = Object.assign || function /*target, ...sources*/\n() {\n  let target = arguments[0];\n  for (let i = 1, len = arguments.length; i < len; i++) {\n    let source = arguments[i];\n    if (source) {\n      for (let prop in source) {\n        if (source.hasOwnProperty(prop)) {\n          target[prop] = source[prop];\n        }\n      }\n    }\n  }\n  return target;\n};\nconst epoch = Date.now();\nconst CONSTRUCTOR_CACHE = new WeakMap();\nconst SHADER_UPGRADE_CACHE = new Map();\n\n// Material ids must be integers, but we can't access the increment from Three's `Material` module,\n// so let's choose a sufficiently large starting value that should theoretically never collide.\nlet materialInstanceId = 1e10;\n\n/**\r\n * A utility for creating a custom shader material derived from another material's\r\n * shaders. This allows you to inject custom shader logic and transforms into the\r\n * builtin ThreeJS materials without having to recreate them from scratch.\r\n *\r\n * @param {THREE.Material} baseMaterial - the original material to derive from\r\n *\r\n * @param {Object} options - How the base material should be modified.\r\n * @param {Object} options.defines - Custom `defines` for the material\r\n * @param {Object} options.extensions - Custom `extensions` for the material, e.g. `{derivatives: true}`\r\n * @param {Object} options.uniforms - Custom `uniforms` for use in the modified shader. These can\r\n *        be accessed and manipulated via the resulting material's `uniforms` property, just like\r\n *        in a ShaderMaterial. You do not need to repeat the base material's own uniforms here.\r\n * @param {String} options.timeUniform - If specified, a uniform of this name will be injected into\r\n *        both shaders, and it will automatically be updated on each render frame with a number of\r\n *        elapsed milliseconds. The \"zero\" epoch time is not significant so don't rely on this as a\r\n *        true calendar time.\r\n * @param {String} options.vertexDefs - Custom GLSL code to inject into the vertex shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.vertexMainIntro - Custom GLSL code to inject at the top of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexMainOutro - Custom GLSL code to inject at the end of the vertex\r\n *        shader's `void main` function.\r\n * @param {String} options.vertexTransform - Custom GLSL code to manipulate the `position`, `normal`,\r\n *        and/or `uv` vertex attributes. This code will be wrapped within a standalone function with\r\n *        those attributes exposed by their normal names as read/write values.\r\n * @param {String} options.fragmentDefs - Custom GLSL code to inject into the fragment shader's top-level\r\n *        definitions, above the `void main()` function.\r\n * @param {String} options.fragmentMainIntro - Custom GLSL code to inject at the top of the fragment\r\n *        shader's `void main` function.\r\n * @param {String} options.fragmentMainOutro - Custom GLSL code to inject at the end of the fragment\r\n *        shader's `void main` function. You can manipulate `gl_FragColor` here but keep in mind it goes\r\n *        after any of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), so if you\r\n *        want those to apply to your changes use `fragmentColorTransform` instead.\r\n * @param {String} options.fragmentColorTransform - Custom GLSL code to manipulate the `gl_FragColor`\r\n *        output value. Will be injected near the end of the `void main` function, but before any\r\n *        of ThreeJS's color postprocessing shader chunks (tonemapping, fog, etc.), and before the\r\n *        `fragmentMainOutro`.\r\n * @param {function<{vertexShader,fragmentShader}>:{vertexShader,fragmentShader}} options.customRewriter - A function\r\n *        for performing custom rewrites of the full shader code. Useful if you need to do something\r\n *        special that's not covered by the other builtin options. This function will be executed before\r\n *        any other transforms are applied.\r\n * @param {boolean} options.chained - Set to `true` to prototype-chain the derived material to the base\r\n *        material, rather than the default behavior of copying it. This allows the derived material to\r\n *        automatically pick up changes made to the base material and its properties. This can be useful\r\n *        where the derived material is hidden from the user as an implementation detail, allowing them\r\n *        to work with the original material like normal. But it can result in unexpected behavior if not\r\n *        handled carefully.\r\n *\r\n * @return {THREE.Material}\r\n *\r\n * The returned material will also have two new methods, `getDepthMaterial()` and `getDistanceMaterial()`,\r\n * which can be called to get a variant of the derived material for use in shadow casting. If the\r\n * target mesh is expected to cast shadows, then you can assign these to the mesh's `customDepthMaterial`\r\n * (for directional and spot lights) and/or `customDistanceMaterial` (for point lights) properties to\r\n * allow the cast shadow to honor your derived shader's vertex transforms and discarded fragments. These\r\n * will also set a custom `#define IS_DEPTH_MATERIAL` or `#define IS_DISTANCE_MATERIAL` that you can look\r\n * for in your derived shaders with `#ifdef` to customize their behavior for the depth or distance\r\n * scenarios, e.g. skipping antialiasing or expensive shader logic.\r\n */\nfunction createDerivedMaterial(baseMaterial, options) {\n  // Generate a key that is unique to the content of these `options`. We'll use this\n  // throughout for caching and for generating the upgraded shader code. This increases\n  // the likelihood that the resulting shaders will line up across multiple calls so\n  // their GL programs can be shared and cached.\n  const optionsKey = getKeyForOptions(options);\n\n  // First check to see if we've already derived from this baseMaterial using this\n  // unique set of options, and if so reuse the constructor to avoid some allocations.\n  let ctorsByDerivation = CONSTRUCTOR_CACHE.get(baseMaterial);\n  if (!ctorsByDerivation) {\n    CONSTRUCTOR_CACHE.set(baseMaterial, ctorsByDerivation = Object.create(null));\n  }\n  if (ctorsByDerivation[optionsKey]) {\n    return new ctorsByDerivation[optionsKey]();\n  }\n  const privateBeforeCompileProp = `_onBeforeCompile${optionsKey}`;\n\n  // Private onBeforeCompile handler that injects the modified shaders and uniforms when\n  // the renderer switches to this material's program\n  const onBeforeCompile = function (shaderInfo) {\n    baseMaterial.onBeforeCompile.call(this, shaderInfo);\n\n    // Upgrade the shaders, caching the result by incoming source code\n    const cacheKey = optionsKey + '|||' + shaderInfo.vertexShader + '|||' + shaderInfo.fragmentShader;\n    let upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey];\n    if (!upgradedShaders) {\n      const upgraded = upgradeShaders(shaderInfo, options, optionsKey);\n      upgradedShaders = SHADER_UPGRADE_CACHE[cacheKey] = upgraded;\n    }\n\n    // Inject upgraded shaders and uniforms into the program\n    shaderInfo.vertexShader = upgradedShaders.vertexShader;\n    shaderInfo.fragmentShader = upgradedShaders.fragmentShader;\n    assign(shaderInfo.uniforms, this.uniforms);\n\n    // Inject auto-updating time uniform if requested\n    if (options.timeUniform) {\n      shaderInfo.uniforms[options.timeUniform] = {\n        get value() {\n          return Date.now() - epoch;\n        }\n      };\n    }\n\n    // Users can still add their own handlers on top of ours\n    if (this[privateBeforeCompileProp]) {\n      this[privateBeforeCompileProp](shaderInfo);\n    }\n  };\n  const DerivedMaterial = function DerivedMaterial() {\n    return derive(options.chained ? baseMaterial : baseMaterial.clone());\n  };\n  const derive = function (base) {\n    // Prototype chain to the base material\n    const derived = Object.create(base, descriptor);\n\n    // Store the baseMaterial for reference; this is always the original even when cloning\n    Object.defineProperty(derived, 'baseMaterial', {\n      value: baseMaterial\n    });\n\n    // Needs its own ids\n    Object.defineProperty(derived, 'id', {\n      value: materialInstanceId++\n    });\n    derived.uuid = MathUtils.generateUUID();\n\n    // Merge uniforms, defines, and extensions\n    derived.uniforms = assign({}, base.uniforms, options.uniforms);\n    derived.defines = assign({}, base.defines, options.defines);\n    derived.defines[`TROIKA_DERIVED_MATERIAL_${optionsKey}`] = ''; //force a program change from the base material\n    derived.extensions = assign({}, base.extensions, options.extensions);\n\n    // Don't inherit EventDispatcher listeners\n    derived._listeners = undefined;\n    return derived;\n  };\n  const descriptor = {\n    constructor: {\n      value: DerivedMaterial\n    },\n    isDerivedMaterial: {\n      value: true\n    },\n    customProgramCacheKey: {\n      value: function () {\n        return optionsKey;\n      }\n    },\n    onBeforeCompile: {\n      get() {\n        return onBeforeCompile;\n      },\n      set(fn) {\n        this[privateBeforeCompileProp] = fn;\n      }\n    },\n    copy: {\n      writable: true,\n      configurable: true,\n      value: function (source) {\n        baseMaterial.copy.call(this, source);\n        if (!baseMaterial.isShaderMaterial && !baseMaterial.isDerivedMaterial) {\n          assign(this.extensions, source.extensions);\n          assign(this.defines, source.defines);\n          assign(this.uniforms, UniformsUtils.clone(source.uniforms));\n        }\n        return this;\n      }\n    },\n    clone: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        const newBase = new baseMaterial.constructor();\n        return derive(newBase).copy(this);\n      }\n    },\n    /**\r\n     * Utility to get a MeshDepthMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDepthMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let depthMaterial = this._depthMaterial;\n        if (!depthMaterial) {\n          depthMaterial = this._depthMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDepthMaterial() : new MeshDepthMaterial({\n            depthPacking: RGBADepthPacking\n          }), options);\n          depthMaterial.defines.IS_DEPTH_MATERIAL = '';\n          depthMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return depthMaterial;\n      }\n    },\n    /**\r\n     * Utility to get a MeshDistanceMaterial that will honor this derived material's vertex\r\n     * transformations and discarded fragments.\r\n     */\n    getDistanceMaterial: {\n      writable: true,\n      configurable: true,\n      value: function () {\n        let distanceMaterial = this._distanceMaterial;\n        if (!distanceMaterial) {\n          distanceMaterial = this._distanceMaterial = createDerivedMaterial(baseMaterial.isDerivedMaterial ? baseMaterial.getDistanceMaterial() : new MeshDistanceMaterial(), options);\n          distanceMaterial.defines.IS_DISTANCE_MATERIAL = '';\n          distanceMaterial.uniforms = this.uniforms; //automatically recieve same uniform values\n        }\n        return distanceMaterial;\n      }\n    },\n    dispose: {\n      writable: true,\n      configurable: true,\n      value() {\n        const {\n          _depthMaterial,\n          _distanceMaterial\n        } = this;\n        if (_depthMaterial) _depthMaterial.dispose();\n        if (_distanceMaterial) _distanceMaterial.dispose();\n        baseMaterial.dispose.call(this);\n      }\n    }\n  };\n  ctorsByDerivation[optionsKey] = DerivedMaterial;\n  return new DerivedMaterial();\n}\nfunction upgradeShaders({\n  vertexShader,\n  fragmentShader\n}, options, key) {\n  let {\n    vertexDefs,\n    vertexMainIntro,\n    vertexMainOutro,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro,\n    fragmentMainOutro,\n    fragmentColorTransform,\n    customRewriter,\n    timeUniform\n  } = options;\n  vertexDefs = vertexDefs || '';\n  vertexMainIntro = vertexMainIntro || '';\n  vertexMainOutro = vertexMainOutro || '';\n  fragmentDefs = fragmentDefs || '';\n  fragmentMainIntro = fragmentMainIntro || '';\n  fragmentMainOutro = fragmentMainOutro || '';\n\n  // Expand includes if needed\n  if (vertexTransform || customRewriter) {\n    vertexShader = expandShaderIncludes(vertexShader);\n  }\n  if (fragmentColorTransform || customRewriter) {\n    // We need to be able to find postprocessing chunks after include expansion in order to\n    // put them after the fragmentColorTransform, so mark them with comments first. Even if\n    // this particular derivation doesn't have a fragmentColorTransform, other derivations may,\n    // so we still mark them.\n    fragmentShader = fragmentShader.replace(/^[ \\t]*#include <((?:tonemapping|encodings|fog|premultiplied_alpha|dithering)_fragment)>/gm, '\\n//!BEGIN_POST_CHUNK $1\\n$&\\n//!END_POST_CHUNK\\n');\n    fragmentShader = expandShaderIncludes(fragmentShader);\n  }\n\n  // Apply custom rewriter function\n  if (customRewriter) {\n    let res = customRewriter({\n      vertexShader,\n      fragmentShader\n    });\n    vertexShader = res.vertexShader;\n    fragmentShader = res.fragmentShader;\n  }\n\n  // The fragmentColorTransform needs to go before any postprocessing chunks, so extract\n  // those and re-insert them into the outro in the correct place:\n  if (fragmentColorTransform) {\n    let postChunks = [];\n    fragmentShader = fragmentShader.replace(/^\\/\\/!BEGIN_POST_CHUNK[^]+?^\\/\\/!END_POST_CHUNK/gm,\n    // [^]+? = non-greedy match of any chars including newlines\n    match => {\n      postChunks.push(match);\n      return '';\n    });\n    fragmentMainOutro = `${fragmentColorTransform}\\n${postChunks.join('\\n')}\\n${fragmentMainOutro}`;\n  }\n\n  // Inject auto-updating time uniform if requested\n  if (timeUniform) {\n    const code = `\\nuniform float ${timeUniform};\\n`;\n    vertexDefs = code + vertexDefs;\n    fragmentDefs = code + fragmentDefs;\n  }\n\n  // Inject a function for the vertexTransform and rename all usages of position/normal/uv\n  if (vertexTransform) {\n    vertexDefs = `${vertexDefs}\nvec3 troika_position_${key};\nvec3 troika_normal_${key};\nvec2 troika_uv_${key};\nvoid troikaVertexTransform${key}(inout vec3 position, inout vec3 normal, inout vec2 uv) {\n  ${vertexTransform}\n}\n`;\n    vertexMainIntro = `\ntroika_position_${key} = vec3(position);\ntroika_normal_${key} = vec3(normal);\ntroika_uv_${key} = vec2(uv);\ntroikaVertexTransform${key}(troika_position_${key}, troika_normal_${key}, troika_uv_${key});\n${vertexMainIntro}\n`;\n    vertexShader = vertexShader.replace(/\\b(position|normal|uv)\\b/g, (match, match1, index, fullStr) => {\n      return /\\battribute\\s+vec[23]\\s+$/.test(fullStr.substr(0, index)) ? match1 : `troika_${match1}_${key}`;\n    });\n  }\n\n  // Inject defs and intro/outro snippets\n  vertexShader = injectIntoShaderCode(vertexShader, key, vertexDefs, vertexMainIntro, vertexMainOutro);\n  fragmentShader = injectIntoShaderCode(fragmentShader, key, fragmentDefs, fragmentMainIntro, fragmentMainOutro);\n  return {\n    vertexShader,\n    fragmentShader\n  };\n}\nfunction injectIntoShaderCode(shaderCode, id, defs, intro, outro) {\n  if (intro || outro || defs) {\n    shaderCode = shaderCode.replace(voidMainRegExp, `\n${defs}\nvoid troikaOrigMain${id}() {`);\n    shaderCode += `\nvoid main() {\n  ${intro}\n  troikaOrigMain${id}();\n  ${outro}\n}`;\n  }\n  return shaderCode;\n}\nfunction optionsJsonReplacer(key, value) {\n  return key === 'uniforms' ? undefined : typeof value === 'function' ? value.toString() : value;\n}\nlet _idCtr = 0;\nconst optionsHashesToIds = new Map();\nfunction getKeyForOptions(options) {\n  const optionsHash = JSON.stringify(options, optionsJsonReplacer);\n  let id = optionsHashesToIds.get(optionsHash);\n  if (id == null) {\n    optionsHashesToIds.set(optionsHash, id = ++_idCtr);\n  }\n  return id;\n}\n\n// Copied from threejs WebGLPrograms.js so we can resolve builtin materials to their shaders\n// TODO how can we keep this from getting stale?\nconst MATERIAL_TYPES_TO_SHADERS = {\n  MeshDepthMaterial: 'depth',\n  MeshDistanceMaterial: 'distanceRGBA',\n  MeshNormalMaterial: 'normal',\n  MeshBasicMaterial: 'basic',\n  MeshLambertMaterial: 'lambert',\n  MeshPhongMaterial: 'phong',\n  MeshToonMaterial: 'phong',\n  MeshStandardMaterial: 'physical',\n  MeshPhysicalMaterial: 'physical',\n  MeshMatcapMaterial: 'matcap',\n  LineBasicMaterial: 'basic',\n  LineDashedMaterial: 'dashed',\n  PointsMaterial: 'points',\n  ShadowMaterial: 'shadow',\n  SpriteMaterial: 'sprite'\n};\n\n/**\r\n * Given a Three.js `Material` instance, find the shaders/uniforms that will be\r\n * used to render that material.\r\n *\r\n * @param material - the Material instance\r\n * @return {object} - the material's shader info: `{uniforms:{}, fragmentShader:'', vertexShader:''}`\r\n */\nfunction getShadersForMaterial(material) {\n  let builtinType = MATERIAL_TYPES_TO_SHADERS[material.type];\n  return builtinType ? ShaderLib[builtinType] : material; //TODO fallback for unknown type?\n}\n\n/**\r\n * Find all uniforms and their types within a shader code string.\r\n *\r\n * @param {string} shader - The shader code to parse\r\n * @return {object} mapping of uniform names to their glsl type\r\n */\nfunction getShaderUniformTypes(shader) {\n  let uniformRE = /\\buniform\\s+(int|float|vec[234])\\s+([A-Za-z_][\\w]*)/g;\n  let uniforms = Object.create(null);\n  let match;\n  while ((match = uniformRE.exec(shader)) !== null) {\n    uniforms[match[2]] = match[1];\n  }\n  return uniforms;\n}\n\n/**\r\n * @class ShaderFloatArray\r\n *\r\n * When writing a custom WebGL shader, sometimes you need to pass it an array of floating\r\n * point numbers that it can read from. Unfortunately this is very difficult to do in WebGL,\r\n * because:\r\n *\r\n *   - GLSL \"array\" uniforms can only be of a constant length.\r\n *   - Textures can only hold floating point numbers in WebGL1 if the `OES_texture_float`\r\n *     extension is available.\r\n *\r\n * ShaderFloatArray is an array-like abstraction that encodes its floating point data into\r\n * an RGBA texture's four Uint8 components, and provides the corresponding ThreeJS uniforms\r\n * and GLSL code for you to put in your custom shader to query the float values by array index.\r\n *\r\n * This should generally only be used within a fragment shader, as some environments (e.g. iOS)\r\n * only allow texture lookups in fragment shaders.\r\n *\r\n * TODO:\r\n *   - Fix texture to fill both dimensions so we don't easily hit max texture size limits\r\n *   - Use a float texture if the extension is available so we can skip the encoding process\r\n */\nclass ShaderFloatArray {\n  constructor(name) {\n    this.name = name;\n    this.textureUniform = `dataTex_${name}`;\n    this.textureSizeUniform = `dataTexSize_${name}`;\n    this.multiplierUniform = `dataMultiplier_${name}`;\n\n    /**\r\n     * @property dataSizeUniform - the name of the GLSL uniform that will hold the\r\n     * length of the data array.\r\n     * @type {string}\r\n     */\n    this.dataSizeUniform = `dataSize_${name}`;\n\n    /**\r\n     * @property readFunction - the name of the GLSL function that should be called to\r\n     * read data out of the array by index.\r\n     * @type {string}\r\n     */\n    this.readFunction = `readData_${name}`;\n    this._raw = new Float32Array(0);\n    this._texture = new DataTexture(new Uint8Array(0), 0, 1);\n    this._length = 0;\n    this._multiplier = 1;\n  }\n\n  /**\r\n   * @property length - the current length of the data array\r\n   * @type {number}\r\n   */\n  set length(value) {\n    if (value !== this._length) {\n      // Find nearest power-of-2 that holds the new length\n      const size = Math.pow(2, Math.ceil(Math.log2(value)));\n      const raw = this._raw;\n      if (size < raw.length) {\n        this._raw = raw.subarray(0, size);\n      } else if (size > raw.length) {\n        this._raw = new Float32Array(size);\n        this._raw.set(raw);\n      }\n      this._length = value;\n    }\n  }\n  get length() {\n    return this._length;\n  }\n\n  /**\r\n   * Add a value to the end of the data array\r\n   * @param {number} value\r\n   */\n  push(value) {\n    return this.set(this.length++, value);\n  }\n\n  /**\r\n   * Replace the existing data with that from a new array\r\n   * @param {ArrayLike<number>} array\r\n   */\n  setArray(array) {\n    this.length = array.length;\n    this._raw.set(array);\n    this._needsRepack = true;\n  }\n\n  /**\r\n   * Get the current value at index\r\n   * @param {number} index\r\n   * @return {number}\r\n   */\n  get(index) {\n    return this._raw[index];\n  }\n  set(index, value) {\n    if (index + 1 > this._length) {\n      this.length = index + 1;\n    }\n    if (value !== this._raw[index]) {\n      this._raw[index] = value;\n      encodeFloatToFourInts(value / this._multiplier, this._texture.image.data, index * 4);\n      this._needsMultCheck = true;\n    }\n  }\n\n  /**\r\n   * Make a copy of this ShaderFloatArray\r\n   * @return {ShaderFloatArray}\r\n   */\n  clone() {\n    const clone = new ShaderFloatArray(this.name);\n    clone.setArray(this._raw);\n    return clone;\n  }\n\n  /**\r\n   * Retrieve the set of Uniforms that must to be added to the target ShaderMaterial or\r\n   * DerivedMaterial, to feed the GLSL code generated by {@link #getShaderHeaderCode}.\r\n   * @return {Object}\r\n   */\n  getShaderUniforms() {\n    const me = this;\n    return {\n      [this.textureUniform]: {\n        get value() {\n          me._sync();\n          return me._texture;\n        }\n      },\n      [this.textureSizeUniform]: {\n        get value() {\n          me._sync();\n          return me._texture.image.width;\n        }\n      },\n      [this.dataSizeUniform]: {\n        get value() {\n          me._sync();\n          return me.length;\n        }\n      },\n      [this.multiplierUniform]: {\n        get value() {\n          me._sync();\n          return me._multiplier;\n        }\n      }\n    };\n  }\n\n  /**\r\n   * Retrieve the GLSL code that must be injected into the shader's definitions area to\r\n   * enable reading from the data array. This exposes a function with a name matching\r\n   * the {@link #readFunction} property, which other shader code can call to read values\r\n   * from the array by their index.\r\n   * @return {string}\r\n   */\n  getShaderHeaderCode() {\n    const {\n      textureUniform,\n      textureSizeUniform,\n      dataSizeUniform,\n      multiplierUniform,\n      readFunction\n    } = this;\n    return `\nuniform sampler2D ${textureUniform};\nuniform float ${textureSizeUniform};\nuniform float ${dataSizeUniform};\nuniform float ${multiplierUniform};\n\nfloat ${readFunction}(float index) {\n  vec2 texUV = vec2((index + 0.5) / ${textureSizeUniform}, 0.5);\n  vec4 pixel = texture2D(${textureUniform}, texUV);\n  return dot(pixel, 1.0 / vec4(1.0, 255.0, 65025.0, 16581375.0)) * ${multiplierUniform};\n}\n`;\n  }\n\n  /**\r\n   * @private Synchronize any pending changes to the underlying DataTexture\r\n   */\n  _sync() {\n    const tex = this._texture;\n    const raw = this._raw;\n    let needsRepack = this._needsRepack;\n\n    // If the size of the raw array changed, resize the texture to match\n    if (raw.length !== tex.image.width) {\n      tex.image = {\n        data: new Uint8Array(raw.length * 4),\n        width: raw.length,\n        height: 1\n      };\n      needsRepack = true;\n    }\n\n    // If the values changed, check the multiplier. This should be a value by which\n    // all the values are divided to constrain them to the [0,1] range required by\n    // the Uint8 packing algorithm. We pick the nearest power of 2 that holds the\n    // maximum value for greatest accuracy.\n    if (needsRepack || this._needsMultCheck) {\n      const maxVal = this._raw.reduce((a, b) => Math.max(a, b), 0);\n      const mult = Math.pow(2, Math.ceil(Math.log2(maxVal)));\n      if (mult !== this._multiplier) {\n        this._multiplier = mult;\n        needsRepack = true;\n      }\n      tex.needsUpdate = true;\n      this._needsMultCheck = false;\n    }\n\n    // If things changed in a way we need to repack, do so\n    if (needsRepack) {\n      for (let i = 0, len = raw.length, mult = this._multiplier; i < len; i++) {\n        encodeFloatToFourInts(raw[i] / mult, tex.image.data, i * 4);\n      }\n      this._needsRepack = false;\n    }\n  }\n}\n\n/**\r\n * Encode a floating point number into a set of four 8-bit integers.\r\n * Also see the companion decoder function #decodeFloatFromFourInts.\r\n *\r\n * This is adapted to JavaScript from the basic approach at\r\n * http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\r\n * but writes out integers in the range 0-255 instead of floats in the range 0-1\r\n * so they can be more easily used in a Uint8Array for standard WebGL rgba textures.\r\n *\r\n * Some precision will necessarily be lost during the encoding and decoding process.\r\n * Testing shows that the maximum precision error is ~1.18e-10 which should be good\r\n * enough for most cases.\r\n *\r\n * @param {Number} value - the floating point number to encode. Must be in the range [0, 1]\r\n *        otherwise the results will be incorrect.\r\n * @param {Array|Uint8Array} array - an array into which the four ints should be written\r\n * @param {Number} startIndex - index in the output array at which to start writing the ints\r\n * @return {Array|Uint8Array}\r\n */\nfunction encodeFloatToFourInts(value, array, startIndex) {\n  // This is adapted to JS from the basic approach at\n  // http://aras-p.info/blog/2009/07/30/encoding-floats-to-rgba-the-final/\n  // but writes to a Uint8Array instead of floats. Input values must be in\n  // the range [0, 1]. The maximum error after encoding and decoding is ~1.18e-10\n  let enc0 = 255 * value;\n  let enc1 = 255 * (enc0 % 1);\n  let enc2 = 255 * (enc1 % 1);\n  let enc3 = 255 * (enc2 % 1);\n  enc0 = enc0 & 255;\n  enc1 = enc1 & 255;\n  enc2 = enc2 & 255;\n  enc3 = Math.round(enc3) & 255;\n  array[startIndex] = enc0;\n  array[startIndex + 1] = enc1;\n  array[startIndex + 2] = enc2;\n  array[startIndex + 3] = enc3;\n  return array;\n}\n\n/*\r\nInput geometry is a cylinder with r=1, height in y dimension from 0 to 1,\r\ndivided into a reasonable number of height segments.\r\n*/\n\nconst vertexDefs = `\nuniform vec3 pointA;\nuniform vec3 controlA;\nuniform vec3 controlB;\nuniform vec3 pointB;\nuniform float radius;\nvarying float bezierT;\n\nvec3 cubicBezier(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  float b0 = t2 * t2 * t2;\n  float b1 = 3.0 * t * t2 * t2;\n  float b2 = 3.0 * t * t * t2;\n  float b3 = t * t * t;\n  return b0 * p1 + b1 * c1 + b2 * c2 + b3 * p2;\n}\n\nvec3 cubicBezierDerivative(vec3 p1, vec3 c1, vec3 c2, vec3 p2, float t) {\n  float t2 = 1.0 - t;\n  return -3.0 * p1 * t2 * t2 +\n    c1 * (3.0 * t2 * t2 - 6.0 * t2 * t) +\n    c2 * (6.0 * t2 * t - 3.0 * t * t) +\n    3.0 * p2 * t * t;\n}\n`;\nconst vertexTransform = `\nfloat t = position.y;\nbezierT = t;\nvec3 bezierCenterPos = cubicBezier(pointA, controlA, controlB, pointB, t);\nvec3 bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t));\n\n// Make \"sideways\" always perpendicular to the camera ray; this ensures that any twists\n// in the cylinder occur where you won't see them: \nvec3 viewDirection = normalMatrix * vec3(0.0, 0.0, 1.0);\nif (bezierDir == viewDirection) {\n  bezierDir = normalize(cubicBezierDerivative(pointA, controlA, controlB, pointB, t == 1.0 ? t - 0.0001 : t + 0.0001));\n}\nvec3 sideways = normalize(cross(bezierDir, viewDirection));\nvec3 upish = normalize(cross(sideways, bezierDir));\n\n// Build a matrix for transforming this disc in the cylinder:\nmat4 discTx;\ndiscTx[0].xyz = sideways * radius;\ndiscTx[1].xyz = bezierDir * radius;\ndiscTx[2].xyz = upish * radius;\ndiscTx[3].xyz = bezierCenterPos;\ndiscTx[3][3] = 1.0;\n\n// Apply transform, ignoring original y\nposition = (discTx * vec4(position.x, 0.0, position.z, 1.0)).xyz;\nnormal = normalize(mat3(discTx) * normal);\n`;\nconst fragmentDefs = `\nuniform vec3 dashing;\nvarying float bezierT;\n`;\nconst fragmentMainIntro = `\nif (dashing.x + dashing.y > 0.0) {\n  float dashFrac = mod(bezierT - dashing.z, dashing.x + dashing.y);\n  if (dashFrac > dashing.x) {\n    discard;\n  }\n}\n`;\n\n// Debugging: separate color for each of the 6 sides:\n// const fragmentColorTransform = `\n// float sideNum = floor(vUV.x * 6.0);\n// vec3 mixColor = sideNum < 1.0 ? vec3(1.0, 0.0, 0.0) :\n//   sideNum < 2.0 ? vec3(0.0, 1.0, 1.0) :\n//   sideNum < 3.0 ? vec3(1.0, 1.0, 0.0) :\n//   sideNum < 4.0 ? vec3(0.0, 0.0, 1.0) :\n//   sideNum < 5.0 ? vec3(0.0, 1.0, 0.0) :\n//   vec3(1.0, 0.0, 1.0);\n// gl_FragColor.xyz = mix(gl_FragColor.xyz, mixColor, 0.5);\n// `\n\nfunction createBezierMeshMaterial(baseMaterial) {\n  return createDerivedMaterial(baseMaterial, {\n    chained: true,\n    uniforms: {\n      pointA: {\n        value: new Vector3()\n      },\n      controlA: {\n        value: new Vector3()\n      },\n      controlB: {\n        value: new Vector3()\n      },\n      pointB: {\n        value: new Vector3()\n      },\n      radius: {\n        value: 0.01\n      },\n      dashing: {\n        value: new Vector3()\n      } //on, off, offset\n    },\n    vertexDefs,\n    vertexTransform,\n    fragmentDefs,\n    fragmentMainIntro\n  });\n}\nlet geometry = null;\nconst defaultBaseMaterial = /*#__PURE__*/new MeshStandardMaterial({\n  color: 0xffffff,\n  side: DoubleSide\n});\n\n/**\r\n * A ThreeJS `Mesh` that bends a tube shape along a 3D cubic bezier path. The bending is done\r\n * by deforming a straight cylindrical geometry in the vertex shader based on a set of four\r\n * control point uniforms. It patches the necessary GLSL into the mesh's assigned `material`\r\n * automatically.\r\n *\r\n * The cubiz bezier path is determined by its four `Vector3` properties:\r\n * - `pointA`\r\n * - `controlA`\r\n * - `controlB`\r\n * - `pointB`\r\n *\r\n * The tube's radius is controlled by its `radius` property, which defaults to `0.01`.\r\n *\r\n * You can also give the tube a dashed appearance with two properties:\r\n *\r\n * - `dashArray` - an array of two numbers, defining the length of \"on\" and \"off\" parts of\r\n *   the dash. Each is a 0-1 ratio of the entire path's length. (Actually this is the `t` length\r\n *   used as input to the cubic bezier function, not its visible length.)\r\n * - `dashOffset` - offset of where the dash starts. You can animate this to make the dashes move.\r\n *\r\n * Note that the dashes will appear like a hollow tube, not solid. This will be more apparent on\r\n * thicker tubes.\r\n *\r\n * TODO: proper geometry bounding sphere and raycasting\r\n * TODO: allow control of the geometry's segment counts\r\n */\nclass BezierMesh extends Mesh {\n  static getGeometry() {\n    return geometry || (geometry = new CylinderBufferGeometry(1, 1, 1, 6, 64).translate(0, 0.5, 0));\n  }\n  constructor() {\n    super(BezierMesh.getGeometry(), defaultBaseMaterial);\n    this.pointA = new Vector3();\n    this.controlA = new Vector3();\n    this.controlB = new Vector3();\n    this.pointB = new Vector3();\n    this.radius = 0.01;\n    this.dashArray = new Vector2();\n    this.dashOffset = 0;\n\n    // TODO - disabling frustum culling until I figure out how to customize the\n    //  geometry's bounding sphere that gets used\n    this.frustumCulled = false;\n  }\n\n  // Handler for automatically wrapping the base material with our upgrades. We do the wrapping\n  // lazily on _read_ rather than write to avoid unnecessary wrapping on transient values.\n  get material() {\n    let derivedMaterial = this._derivedMaterial;\n    const baseMaterial = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = defaultBaseMaterial.clone());\n    if (!derivedMaterial || derivedMaterial.baseMaterial !== baseMaterial) {\n      derivedMaterial = this._derivedMaterial = createBezierMeshMaterial(baseMaterial);\n      // dispose the derived material when its base material is disposed:\n      baseMaterial.addEventListener('dispose', function onDispose() {\n        baseMaterial.removeEventListener('dispose', onDispose);\n        derivedMaterial.dispose();\n      });\n    }\n    return derivedMaterial;\n  }\n  set material(baseMaterial) {\n    this._baseMaterial = baseMaterial;\n  }\n\n  // Create and update material for shadows upon request:\n  get customDepthMaterial() {\n    return this.material.getDepthMaterial();\n  }\n  get customDistanceMaterial() {\n    return this.material.getDistanceMaterial();\n  }\n  onBeforeRender(shaderInfo) {\n    const {\n      uniforms\n    } = this.material;\n    const {\n      pointA,\n      controlA,\n      controlB,\n      pointB,\n      radius,\n      dashArray,\n      dashOffset\n    } = this;\n    uniforms.pointA.value.copy(pointA);\n    uniforms.controlA.value.copy(controlA);\n    uniforms.controlB.value.copy(controlB);\n    uniforms.pointB.value.copy(pointB);\n    uniforms.radius.value = radius;\n    uniforms.dashing.value.set(dashArray.x, dashArray.y, dashOffset || 0);\n  }\n  raycast(raycaster, intersects) {\n    // TODO - just fail for now\n  }\n}\nexport { BezierMesh, ShaderFloatArray, createDerivedMaterial, expandShaderIncludes, getShaderUniformTypes, getShadersForMaterial, voidMainRegExp };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}