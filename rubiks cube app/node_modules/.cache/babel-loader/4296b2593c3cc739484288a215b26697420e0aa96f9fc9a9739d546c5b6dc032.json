{"ast":null,"code":"import { EventDispatcher, MOUSE, Quaternion, Vector2, Vector3 } from \"../../../build/three.module.js\";\nvar TrackballControls = function (object, domElement) {\n  if (domElement === undefined) console.warn('THREE.TrackballControls: The second parameter \"domElement\" is now mandatory.');\n  if (domElement === document) console.error('THREE.TrackballControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.');\n  var scope = this;\n  var STATE = {\n    NONE: -1,\n    ROTATE: 0,\n    ZOOM: 1,\n    PAN: 2,\n    TOUCH_ROTATE: 3,\n    TOUCH_ZOOM_PAN: 4\n  };\n  this.object = object;\n  this.domElement = domElement;\n\n  // API\n\n  this.enabled = true;\n  this.screen = {\n    left: 0,\n    top: 0,\n    width: 0,\n    height: 0\n  };\n  this.rotateSpeed = 1.0;\n  this.zoomSpeed = 1.2;\n  this.panSpeed = 0.3;\n  this.noRotate = false;\n  this.noZoom = false;\n  this.noPan = false;\n  this.staticMoving = false;\n  this.dynamicDampingFactor = 0.2;\n  this.minDistance = 0;\n  this.maxDistance = Infinity;\n  this.keys = [65 /*A*/, 83 /*S*/, 68 /*D*/];\n  this.mouseButtons = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.ZOOM,\n    RIGHT: MOUSE.PAN\n  };\n\n  // internals\n\n  this.target = new Vector3();\n  var EPS = 0.000001;\n  var lastPosition = new Vector3();\n  var lastZoom = 1;\n  var _state = STATE.NONE,\n    _keyState = STATE.NONE,\n    _eye = new Vector3(),\n    _movePrev = new Vector2(),\n    _moveCurr = new Vector2(),\n    _lastAxis = new Vector3(),\n    _lastAngle = 0,\n    _zoomStart = new Vector2(),\n    _zoomEnd = new Vector2(),\n    _touchZoomDistanceStart = 0,\n    _touchZoomDistanceEnd = 0,\n    _panStart = new Vector2(),\n    _panEnd = new Vector2();\n\n  // for reset\n\n  this.target0 = this.target.clone();\n  this.position0 = this.object.position.clone();\n  this.up0 = this.object.up.clone();\n  this.zoom0 = this.object.zoom;\n\n  // events\n\n  var changeEvent = {\n    type: 'change'\n  };\n  var startEvent = {\n    type: 'start'\n  };\n  var endEvent = {\n    type: 'end'\n  };\n\n  // methods\n\n  this.handleResize = function () {\n    var box = scope.domElement.getBoundingClientRect();\n    // adjustments come from similar code in the jquery offset() function\n    var d = scope.domElement.ownerDocument.documentElement;\n    scope.screen.left = box.left + window.pageXOffset - d.clientLeft;\n    scope.screen.top = box.top + window.pageYOffset - d.clientTop;\n    scope.screen.width = box.width;\n    scope.screen.height = box.height;\n  };\n  var getMouseOnScreen = function () {\n    var vector = new Vector2();\n    return function getMouseOnScreen(pageX, pageY) {\n      vector.set((pageX - scope.screen.left) / scope.screen.width, (pageY - scope.screen.top) / scope.screen.height);\n      return vector;\n    };\n  }();\n  var getMouseOnCircle = function () {\n    var vector = new Vector2();\n    return function getMouseOnCircle(pageX, pageY) {\n      vector.set((pageX - scope.screen.width * 0.5 - scope.screen.left) / (scope.screen.width * 0.5), (scope.screen.height + 2 * (scope.screen.top - pageY)) / scope.screen.width // screen.width intentional\n      );\n      return vector;\n    };\n  }();\n  this.rotateCamera = function () {\n    var axis = new Vector3(),\n      quaternion = new Quaternion(),\n      eyeDirection = new Vector3(),\n      objectUpDirection = new Vector3(),\n      objectSidewaysDirection = new Vector3(),\n      moveDirection = new Vector3(),\n      angle;\n    return function rotateCamera() {\n      moveDirection.set(_moveCurr.x - _movePrev.x, _moveCurr.y - _movePrev.y, 0);\n      angle = moveDirection.length();\n      if (angle) {\n        _eye.copy(scope.object.position).sub(scope.target);\n        eyeDirection.copy(_eye).normalize();\n        objectUpDirection.copy(scope.object.up).normalize();\n        objectSidewaysDirection.crossVectors(objectUpDirection, eyeDirection).normalize();\n        objectUpDirection.setLength(_moveCurr.y - _movePrev.y);\n        objectSidewaysDirection.setLength(_moveCurr.x - _movePrev.x);\n        moveDirection.copy(objectUpDirection.add(objectSidewaysDirection));\n        axis.crossVectors(moveDirection, _eye).normalize();\n        angle *= scope.rotateSpeed;\n        quaternion.setFromAxisAngle(axis, angle);\n        _eye.applyQuaternion(quaternion);\n        scope.object.up.applyQuaternion(quaternion);\n        _lastAxis.copy(axis);\n        _lastAngle = angle;\n      } else if (!scope.staticMoving && _lastAngle) {\n        _lastAngle *= Math.sqrt(1.0 - scope.dynamicDampingFactor);\n        _eye.copy(scope.object.position).sub(scope.target);\n        quaternion.setFromAxisAngle(_lastAxis, _lastAngle);\n        _eye.applyQuaternion(quaternion);\n        scope.object.up.applyQuaternion(quaternion);\n      }\n      _movePrev.copy(_moveCurr);\n    };\n  }();\n  this.zoomCamera = function () {\n    var factor;\n    if (_state === STATE.TOUCH_ZOOM_PAN) {\n      factor = _touchZoomDistanceStart / _touchZoomDistanceEnd;\n      _touchZoomDistanceStart = _touchZoomDistanceEnd;\n      if (scope.object.isPerspectiveCamera) {\n        _eye.multiplyScalar(factor);\n      } else if (scope.object.isOrthographicCamera) {\n        scope.object.zoom *= factor;\n        scope.object.updateProjectionMatrix();\n      } else {\n        console.warn('THREE.TrackballControls: Unsupported camera type');\n      }\n    } else {\n      factor = 1.0 + (_zoomEnd.y - _zoomStart.y) * scope.zoomSpeed;\n      if (factor !== 1.0 && factor > 0.0) {\n        if (scope.object.isPerspectiveCamera) {\n          _eye.multiplyScalar(factor);\n        } else if (scope.object.isOrthographicCamera) {\n          scope.object.zoom /= factor;\n          scope.object.updateProjectionMatrix();\n        } else {\n          console.warn('THREE.TrackballControls: Unsupported camera type');\n        }\n      }\n      if (scope.staticMoving) {\n        _zoomStart.copy(_zoomEnd);\n      } else {\n        _zoomStart.y += (_zoomEnd.y - _zoomStart.y) * this.dynamicDampingFactor;\n      }\n    }\n  };\n  this.panCamera = function () {\n    var mouseChange = new Vector2(),\n      objectUp = new Vector3(),\n      pan = new Vector3();\n    return function panCamera() {\n      mouseChange.copy(_panEnd).sub(_panStart);\n      if (mouseChange.lengthSq()) {\n        if (scope.object.isOrthographicCamera) {\n          var scale_x = (scope.object.right - scope.object.left) / scope.object.zoom / scope.domElement.clientWidth;\n          var scale_y = (scope.object.top - scope.object.bottom) / scope.object.zoom / scope.domElement.clientWidth;\n          mouseChange.x *= scale_x;\n          mouseChange.y *= scale_y;\n        }\n        mouseChange.multiplyScalar(_eye.length() * scope.panSpeed);\n        pan.copy(_eye).cross(scope.object.up).setLength(mouseChange.x);\n        pan.add(objectUp.copy(scope.object.up).setLength(mouseChange.y));\n        scope.object.position.add(pan);\n        scope.target.add(pan);\n        if (scope.staticMoving) {\n          _panStart.copy(_panEnd);\n        } else {\n          _panStart.add(mouseChange.subVectors(_panEnd, _panStart).multiplyScalar(scope.dynamicDampingFactor));\n        }\n      }\n    };\n  }();\n  this.checkDistances = function () {\n    if (!scope.noZoom || !scope.noPan) {\n      if (_eye.lengthSq() > scope.maxDistance * scope.maxDistance) {\n        scope.object.position.addVectors(scope.target, _eye.setLength(scope.maxDistance));\n        _zoomStart.copy(_zoomEnd);\n      }\n      if (_eye.lengthSq() < scope.minDistance * scope.minDistance) {\n        scope.object.position.addVectors(scope.target, _eye.setLength(scope.minDistance));\n        _zoomStart.copy(_zoomEnd);\n      }\n    }\n  };\n  this.update = function () {\n    _eye.subVectors(scope.object.position, scope.target);\n    if (!scope.noRotate) {\n      scope.rotateCamera();\n    }\n    if (!scope.noZoom) {\n      scope.zoomCamera();\n    }\n    if (!scope.noPan) {\n      scope.panCamera();\n    }\n    scope.object.position.addVectors(scope.target, _eye);\n    if (scope.object.isPerspectiveCamera) {\n      scope.checkDistances();\n      scope.object.lookAt(scope.target);\n      if (lastPosition.distanceToSquared(scope.object.position) > EPS) {\n        scope.dispatchEvent(changeEvent);\n        lastPosition.copy(scope.object.position);\n      }\n    } else if (scope.object.isOrthographicCamera) {\n      scope.object.lookAt(scope.target);\n      if (lastPosition.distanceToSquared(scope.object.position) > EPS || lastZoom !== scope.object.zoom) {\n        scope.dispatchEvent(changeEvent);\n        lastPosition.copy(scope.object.position);\n        lastZoom = scope.object.zoom;\n      }\n    } else {\n      console.warn('THREE.TrackballControls: Unsupported camera type');\n    }\n  };\n  this.reset = function () {\n    _state = STATE.NONE;\n    _keyState = STATE.NONE;\n    scope.target.copy(scope.target0);\n    scope.object.position.copy(scope.position0);\n    scope.object.up.copy(scope.up0);\n    scope.object.zoom = scope.zoom0;\n    scope.object.updateProjectionMatrix();\n    _eye.subVectors(scope.object.position, scope.target);\n    scope.object.lookAt(scope.target);\n    scope.dispatchEvent(changeEvent);\n    lastPosition.copy(scope.object.position);\n    lastZoom = scope.object.zoom;\n  };\n\n  // listeners\n\n  function onPointerDown(event) {\n    if (scope.enabled === false) return;\n    switch (event.pointerType) {\n      case 'mouse':\n      case 'pen':\n        onMouseDown(event);\n        break;\n\n      // TODO touch\n    }\n  }\n  function onPointerMove(event) {\n    if (scope.enabled === false) return;\n    switch (event.pointerType) {\n      case 'mouse':\n      case 'pen':\n        onMouseMove(event);\n        break;\n\n      // TODO touch\n    }\n  }\n  function onPointerUp(event) {\n    if (scope.enabled === false) return;\n    switch (event.pointerType) {\n      case 'mouse':\n      case 'pen':\n        onMouseUp(event);\n        break;\n\n      // TODO touch\n    }\n  }\n  function keydown(event) {\n    if (scope.enabled === false) return;\n    window.removeEventListener('keydown', keydown);\n    if (_keyState !== STATE.NONE) {\n      return;\n    } else if (event.keyCode === scope.keys[STATE.ROTATE] && !scope.noRotate) {\n      _keyState = STATE.ROTATE;\n    } else if (event.keyCode === scope.keys[STATE.ZOOM] && !scope.noZoom) {\n      _keyState = STATE.ZOOM;\n    } else if (event.keyCode === scope.keys[STATE.PAN] && !scope.noPan) {\n      _keyState = STATE.PAN;\n    }\n  }\n  function keyup() {\n    if (scope.enabled === false) return;\n    _keyState = STATE.NONE;\n    window.addEventListener('keydown', keydown, false);\n  }\n  function onMouseDown(event) {\n    event.preventDefault();\n    event.stopPropagation();\n    if (_state === STATE.NONE) {\n      switch (event.button) {\n        case scope.mouseButtons.LEFT:\n          _state = STATE.ROTATE;\n          break;\n        case scope.mouseButtons.MIDDLE:\n          _state = STATE.ZOOM;\n          break;\n        case scope.mouseButtons.RIGHT:\n          _state = STATE.PAN;\n          break;\n        default:\n          _state = STATE.NONE;\n      }\n    }\n    var state = _keyState !== STATE.NONE ? _keyState : _state;\n    if (state === STATE.ROTATE && !scope.noRotate) {\n      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n      _movePrev.copy(_moveCurr);\n    } else if (state === STATE.ZOOM && !scope.noZoom) {\n      _zoomStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n      _zoomEnd.copy(_zoomStart);\n    } else if (state === STATE.PAN && !scope.noPan) {\n      _panStart.copy(getMouseOnScreen(event.pageX, event.pageY));\n      _panEnd.copy(_panStart);\n    }\n    scope.domElement.ownerDocument.addEventListener('pointermove', onPointerMove, false);\n    scope.domElement.ownerDocument.addEventListener('pointerup', onPointerUp, false);\n    scope.dispatchEvent(startEvent);\n  }\n  function onMouseMove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    event.stopPropagation();\n    var state = _keyState !== STATE.NONE ? _keyState : _state;\n    if (state === STATE.ROTATE && !scope.noRotate) {\n      _movePrev.copy(_moveCurr);\n      _moveCurr.copy(getMouseOnCircle(event.pageX, event.pageY));\n    } else if (state === STATE.ZOOM && !scope.noZoom) {\n      _zoomEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n    } else if (state === STATE.PAN && !scope.noPan) {\n      _panEnd.copy(getMouseOnScreen(event.pageX, event.pageY));\n    }\n  }\n  function onMouseUp(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    event.stopPropagation();\n    _state = STATE.NONE;\n    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove);\n    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp);\n    scope.dispatchEvent(endEvent);\n  }\n  function mousewheel(event) {\n    if (scope.enabled === false) return;\n    if (scope.noZoom === true) return;\n    event.preventDefault();\n    event.stopPropagation();\n    switch (event.deltaMode) {\n      case 2:\n        // Zoom in pages\n        _zoomStart.y -= event.deltaY * 0.025;\n        break;\n      case 1:\n        // Zoom in lines\n        _zoomStart.y -= event.deltaY * 0.01;\n        break;\n      default:\n        // undefined, 0, assume pixels\n        _zoomStart.y -= event.deltaY * 0.00025;\n        break;\n    }\n    scope.dispatchEvent(startEvent);\n    scope.dispatchEvent(endEvent);\n  }\n  function touchstart(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    switch (event.touches.length) {\n      case 1:\n        _state = STATE.TOUCH_ROTATE;\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n        _movePrev.copy(_moveCurr);\n        break;\n      default:\n        // 2 or more\n        _state = STATE.TOUCH_ZOOM_PAN;\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        _touchZoomDistanceEnd = _touchZoomDistanceStart = Math.sqrt(dx * dx + dy * dy);\n        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n        _panStart.copy(getMouseOnScreen(x, y));\n        _panEnd.copy(_panStart);\n        break;\n    }\n    scope.dispatchEvent(startEvent);\n  }\n  function touchmove(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n    event.stopPropagation();\n    switch (event.touches.length) {\n      case 1:\n        _movePrev.copy(_moveCurr);\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n        break;\n      default:\n        // 2 or more\n        var dx = event.touches[0].pageX - event.touches[1].pageX;\n        var dy = event.touches[0].pageY - event.touches[1].pageY;\n        _touchZoomDistanceEnd = Math.sqrt(dx * dx + dy * dy);\n        var x = (event.touches[0].pageX + event.touches[1].pageX) / 2;\n        var y = (event.touches[0].pageY + event.touches[1].pageY) / 2;\n        _panEnd.copy(getMouseOnScreen(x, y));\n        break;\n    }\n  }\n  function touchend(event) {\n    if (scope.enabled === false) return;\n    switch (event.touches.length) {\n      case 0:\n        _state = STATE.NONE;\n        break;\n      case 1:\n        _state = STATE.TOUCH_ROTATE;\n        _moveCurr.copy(getMouseOnCircle(event.touches[0].pageX, event.touches[0].pageY));\n        _movePrev.copy(_moveCurr);\n        break;\n    }\n    scope.dispatchEvent(endEvent);\n  }\n  function contextmenu(event) {\n    if (scope.enabled === false) return;\n    event.preventDefault();\n  }\n  this.dispose = function () {\n    scope.domElement.removeEventListener('contextmenu', contextmenu, false);\n    scope.domElement.removeEventListener('pointerdown', onPointerDown, false);\n    scope.domElement.removeEventListener('wheel', mousewheel, false);\n    scope.domElement.removeEventListener('touchstart', touchstart, false);\n    scope.domElement.removeEventListener('touchend', touchend, false);\n    scope.domElement.removeEventListener('touchmove', touchmove, false);\n    scope.domElement.ownerDocument.removeEventListener('pointermove', onPointerMove, false);\n    scope.domElement.ownerDocument.removeEventListener('pointerup', onPointerUp, false);\n    window.removeEventListener('keydown', keydown, false);\n    window.removeEventListener('keyup', keyup, false);\n  };\n  this.domElement.addEventListener('contextmenu', contextmenu, false);\n  this.domElement.addEventListener('pointerdown', onPointerDown, false);\n  this.domElement.addEventListener('wheel', mousewheel, false);\n  this.domElement.addEventListener('touchstart', touchstart, false);\n  this.domElement.addEventListener('touchend', touchend, false);\n  this.domElement.addEventListener('touchmove', touchmove, false);\n  this.domElement.ownerDocument.addEventListener('pointermove', onPointerMove, false);\n  this.domElement.ownerDocument.addEventListener('pointerup', onPointerUp, false);\n  window.addEventListener('keydown', keydown, false);\n  window.addEventListener('keyup', keyup, false);\n  this.handleResize();\n\n  // force an update at start\n  this.update();\n};\nTrackballControls.prototype = Object.create(EventDispatcher.prototype);\nTrackballControls.prototype.constructor = TrackballControls;\nexport { TrackballControls };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}